<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Zen Solver</title>
<style>
  :root{
    --navy-900:#0b1220; --navy-850:#0f1a2b; --navy-800:#122036; --navy-750:#152744;
    --blue-500:#3aa0ff; --blue-400:#58b0ff; --blue-300:#8cc8ff;
    --cyan-400:#3af2e8; --green-400:#38d677;
    --text-100:#e6eef7; --text-200:#c3d4ea; --muted-400:#7f9bb9; --danger-400:#ff6b6b;
    --card-radius:12px; --shadow:0 6px 18px rgba(0,0,0,.35); --mono:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 800px at 20% 0%, var(--navy-800), var(--navy-900));
    color:var(--text-100); font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; line-height:1.4;
  }
  .app{display:grid; grid-template-columns:320px 1fr 320px; gap:16px; padding:16px; height:100dvh}
  .card{
    background:linear-gradient(180deg, var(--navy-800), var(--navy-850));
    border:1px solid rgba(90,140,200,.15); border-radius:var(--card-radius); box-shadow:var(--shadow);
    overflow:hidden; display:flex; flex-direction:column;
  }
  .card-header{padding:12px 14px; border-bottom:1px solid rgba(120,170,230,.15); font-weight:600; color:var(--blue-300); display:flex; align-items:center; justify-content:space-between}
  .card-body{padding:14px; overflow:auto}
  .controls{display:grid; gap:12px}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  button,select{
    background:linear-gradient(180deg, var(--navy-750), var(--navy-800));
    border:1px solid rgba(80,130,200,.25); color:var(--text-100); border-radius:10px; padding:10px 12px; font-size:14px; cursor:pointer; transition:all .15s ease;
  }
  button:hover,select:hover{border-color:var(--blue-400); box-shadow:0 0 0 3px rgba(60,160,255,.15) inset}
  button.primary{background:linear-gradient(180deg,#0d2b4a,#0e2141); border-color:rgba(58,160,255,.7); color:var(--blue-300); font-weight:600}
  button.success{border-color:rgba(56,214,119,.6); color:var(--green-400)}
  button.warn{border-color:rgba(255,107,107,.5); color:var(--danger-400)}
  button.ghost{border-color:rgba(120,170,230,.35); color:var(--text-200)}
  button:disabled{opacity:.55; cursor:not-allowed}
  label{display:block; margin-bottom:6px; color:var(--text-200)}
  .status{display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:8px; font-family:var(--mono); font-variant-numeric:tabular-nums}
  .status div{padding:8px; background:linear-gradient(180deg, var(--navy-800), var(--navy-850)); border:1px solid rgba(90,140,200,.2); border-radius:8px; color:var(--text-200)}
  .status strong{color:var(--text-100)}
  .preview-wrap{position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:radial-gradient(800px 600px at 50% 0%, #0e1a2e, #0b1220)}
  video{max-width:100%; max-height:100%; border-radius:10px; border:1px solid rgba(80,130,200,.25); background:#000}
  canvas.overlay{position:absolute}
  .overlay.pe-none{pointer-events:none}
  .overlay.pe-auto{pointer-events:auto}
  .list{display:flex; flex-direction:column; gap:8px}
  .step{display:flex; align-items:center; justify-content:space-between; padding:8px 10px; background:linear-gradient(180deg, var(--navy-800), var(--navy-850)); border:1px solid rgba(90,140,200,.2); border-radius:8px; font-family:var(--mono); font-variant-numeric:tabular-nums}
  .hint{color:var(--muted-400); font-size:13px}
  .grid{display:grid; gap:10px}
  .grid.cols-3{grid-template-columns:1fr 1fr 1fr}
  .divider{height:1px; background:linear-gradient(90deg, transparent, rgba(130,160,210,.25), transparent); margin:8px 0}
  .badge{display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; border:1px solid rgba(90,140,200,.25); color:var(--text-200); font-size:12px; background:linear-gradient(180deg, var(--navy-800), var(--navy-850))}
  .badge .dot{width:8px; height:8px; border-radius:50%; background:var(--blue-500)}
  .legend{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; color:var(--muted-400); font-size:12px}
  .legend span{display:inline-flex; align-items:center; gap:6px}
  .legend .teal{width:10px; height:10px; background:#2dd4d4; border-radius:2px}
  .legend .green{width:10px; height:10px; background:#22c55e; border-radius:2px}
  .legend .board{width:10px; height:10px; background:transparent; border:1px dashed #58b0ff; border-radius:2px}
  @media (max-width:1100px){.app{grid-template-columns:1fr; height:auto}.card-body{max-height:50vh}.preview-wrap{height:50vh}}
</style>
</head>
<body>
  <div class="app">
    <!-- Left: Controls -->
    <section class="card">
      <div class="card-header">
        <div>Controls</div>
        <div class="badge"><span class="dot"></span> Zen Solver</div>
      </div>
      <div class="card-body">
        <div class="controls">
          <div class="row">
            <button id="btnCapture" class="primary">Start Capture</button>
            <button id="btnStopCapture" class="warn" disabled>Stop Capture</button>
          </div>

          <div class="row">
            <button id="btnSetBoard" class="ghost">Set Board</button>
            <button id="btnEditBoard" class="ghost" disabled>Edit Board</button>
            <button id="btnDoneEdit" class="success" disabled>Done</button>
            <button id="btnClearBoard" class="ghost" disabled>Clear</button>
          </div>

          <div class="row">
            <button id="btnCalibrate" class="">Calibrate</button>
            <button id="btnStart" class="success">Start Detection</button>
            <button id="btnStop" class="warn" disabled>Stop Detection</button>
          </div>

          <div class="divider"></div>

          <div>
            <label for="difficulty">Difficulty</label>
            <select id="difficulty">
              <option value="easy">Easy (4×4)</option>
              <option value="medium" selected>Medium (5×5)</option>
              <option value="hard">Hard (6×6)</option>
              <option value="expert">Expert (6×6)</option>
            </select>
            <div class="hint">Changing difficulty clears state and requires setting the board again.</div>
          </div>

          <div class="divider"></div>

          <div>
            <div style="display:flex;align-items:center;justify-content:space-between">
              <label>Detector Config</label>
              <button id="btnRestoreDefaults" title="Restore Defaults">Restore Defaults</button>
            </div>
            <div class="grid cols-3" id="configGrid"></div>
          </div>

          <div class="divider"></div>

          <div class="status" id="status">
            <div>FPS: <strong id="fps">0</strong></div>
            <div>Phase: <strong id="phase">idle</strong></div>
            <div>Round: <strong id="round">1</strong></div>
            <div>Reveal: <strong id="revealCount">0</strong></div>
            <div>Input: <strong id="inputCount">0</strong></div>
            <div>Grid: <strong id="gridSize">5×5</strong></div>
          </div>

          <div class="legend">
            <span><i class="board"></i> Board</span>
            <span><i class="teal"></i> Teal (Reveal)</span>
            <span><i class="green"></i> Green (Input)</span>
            <span>Tip: Set Board → drag a square over the grid, then Edit with corner handles</span>
          </div>
        </div>
      </div>
    </section>

    <!-- Center: Video + Overlay -->
    <section class="card">
      <div class="card-header">Preview</div>
      <div class="preview-wrap" id="previewWrap">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay" class="overlay pe-none"></canvas>
      </div>
    </section>

    <!-- Right: Pattern View -->
    <section class="card">
      <div class="card-header">
        <div>Pattern</div>
        <div class="badge"><span>Input</span> <span id="inputProgress">0 / 3</span></div>
      </div>
      <div class="card-body">
        <div id="sequence" class="list">
          <div class="hint">Detected sequence appears here as (row, col) and index. Repeats are kept.</div>
        </div>
      </div>
    </section>
  </div>

<script>
(function(){
  // DOM
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const previewWrap = document.getElementById('previewWrap');
  const ctxOv = overlay.getContext('2d', { alpha: true });

  const btnCapture = document.getElementById('btnCapture');
  const btnStopCapture = document.getElementById('btnStopCapture');
  const btnSetBoard = document.getElementById('btnSetBoard');
  const btnEditBoard = document.getElementById('btnEditBoard');
  const btnDoneEdit = document.getElementById('btnDoneEdit');
  const btnClearBoard = document.getElementById('btnClearBoard');
  const btnCalibrate = document.getElementById('btnCalibrate');
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');

  const selDifficulty = document.getElementById('difficulty');
  const btnRestoreDefaults = document.getElementById('btnRestoreDefaults');
  const configGrid = document.getElementById('configGrid');

  const elFPS = document.getElementById('fps');
  const elPhase = document.getElementById('phase');
  const elRound = document.getElementById('round');
  const elRevealCount = document.getElementById('revealCount');
  const elInputCount = document.getElementById('inputCount');
  const elGridSize = document.getElementById('gridSize');
  const elInputProgress = document.getElementById('inputProgress');
  const elSequence = document.getElementById('sequence');

  // State
  const defaultConfig = {
    thrHigh:10, thrLow:6, holdFrames:1, refractoryFrames:6, emaAlpha:0.20,
    energyWindow:5, energyScale:2.5, requireColorToStartReveal:true, warmupMs:450,
    surgeRejectPct:0.4, inputTimeoutMs:12000, revealHardTimeoutMs:1800,
    clusterGapMs:900, rearmDelayMs:120,
  };
  const config = { ...defaultConfig };

  let stream=null, track=null, running=false, detectionActive=false, hasBoard=false;

  let difficulty='medium', rows=5, cols=5;

  let boardRect=null; // video coords
  let tileRects=[];

  const work = document.createElement('canvas');
  const wctx = work.getContext('2d', { willReadFrequently:true });

  let tileState=[], sampleOffsets=[];

  // FSM
  let phase='idle', roundIndex=0, revealLenExpected=3;
  let revealSeq=[], inputSeq=[];
  let warmupStartTs=0, revealStartTs=0, lastClusterTs=0, inputStartTs=0, rearmTs=0;

  // FPS
  let lastFPSTs=0, framesInBucket=0;

  // Editor
  const editor = {
    mode: 'idle', // 'idle' | 'draw' | 'edit'
    rect: null,   // display coords
    activeHandle: null, // 'move' | 'nw' | 'ne' | 'se' | 'sw'
    start: {x:0,y:0},
    rectStart: null,
    handleSize: 12
  };

  // Helpers
  function updateGridFromDifficulty(){
    switch(difficulty){
      case 'easy': rows=4; cols=4; break;
      case 'medium': rows=5; cols=5; break;
      case 'hard':
      case 'expert': rows=6; cols=6; break;
      default: rows=5; cols=5;
    }
    elGridSize.textContent = `${cols}×${rows}`;
  }
  function resetDetectionState({clearBoard=true}={}){
    detectionActive=false; btnStart.disabled=false; btnStop.disabled=true;
    phase='idle'; roundIndex=0; revealLenExpected=3; revealSeq=[]; inputSeq=[];
    warmupStartTs=performance.now();
    if (clearBoard){
      boardRect=null; tileRects=[]; tileState=[]; sampleOffsets=[]; hasBoard=false;
      btnEditBoard.disabled=true; btnDoneEdit.disabled=true; btnClearBoard.disabled=true;
      editor.mode='idle'; editor.rect=null; editor.activeHandle=null;
    }
    updateStatus(); renderSequence();
  }
  function updateStatus(){
    elPhase.textContent=phase;
    elRound.textContent=String(roundIndex+1);
    elRevealCount.textContent=String(revealSeq.length);
    elInputCount.textContent=String(inputSeq.length);
    elInputProgress.textContent=`${inputSeq.length} / ${revealLenExpected}`;
  }
  function renderSequence(){
    elSequence.innerHTML='';
    if (revealSeq.length===0 && inputSeq.length===0){
      const d=document.createElement('div'); d.className='hint';
      d.textContent='Detected sequence appears here as (row, col) and index. Repeats are kept.';
      elSequence.appendChild(d); return;
    }
    let i=0;
    for (const idx of revealSeq){
      const t=tileRects[idx]; const r=t?t.row+1:'?'; const c=t?t.col+1:'?';
      const div=document.createElement('div'); div.className='step';
      div.innerHTML=`<span>#${(++i)} — (r${r}, c${c})</span><span>idx ${idx}</span>`;
      elSequence.appendChild(div);
    }
  }
  function createConfigGrid(){
    configGrid.innerHTML='';
    const entries=[
      ['thrHigh',config.thrHigh],['thrLow',config.thrLow],['holdFrames',config.holdFrames],['refractoryFrames',config.refractoryFrames],
      ['emaAlpha',config.emaAlpha],['energyWindow',config.energyWindow],['energyScale',config.energyScale],
      ['requireColorToStartReveal',String(config.requireColorToStartReveal)],['warmupMs',config.warmupMs],['surgeRejectPct',config.surgeRejectPct],
      ['inputTimeoutMs',config.inputTimeoutMs],['revealHardTimeoutMs',config.revealHardTimeoutMs],['clusterGapMs',config.clusterGapMs],['rearmDelayMs',config.rearmDelayMs]
    ];
    for (const [k,v] of entries){
      const wrap=document.createElement('div');
      const lab=document.createElement('div'); lab.style.color='var(--muted-400)'; lab.style.fontSize='12px'; lab.textContent=k;
      const val=document.createElement('div'); val.style.fontFamily='var(--mono)'; val.style.fontVariantNumeric='tabular-nums'; val.textContent=String(v);
      wrap.appendChild(lab); wrap.appendChild(val); configGrid.appendChild(wrap);
    }
  }

  // Capture
  async function startCapture(){
    try{
      stream = await navigator.mediaDevices.getDisplayMedia({
        video:{ displaySurface:'window', frameRate:{ideal:60,max:60}, cursor:'never' }, audio:false
      });
      video.srcObject = stream;
      track = stream.getVideoTracks()[0];
      try{ await track.applyConstraints({ frameRate:{ideal:60,max:60} }); }catch(_){}
      try{ if ('contentHint' in track) track.contentHint='motion'; }catch(_){}
      btnCapture.disabled=true; btnStopCapture.disabled=false;
      running=true; startLoops();
    }catch(e){ console.error(e); alert('Screen/window capture was not granted.'); }
  }
  function stopCapture(){
    if (stream){ stream.getTracks().forEach(t=>t.stop()); }
    stream=null; track=null; video.srcObject=null; running=false;
    btnCapture.disabled=false; btnStopCapture.disabled=true;
  }

  // Math / utils
  function luminance(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }

  function buildTilesFromSquare(bx,by,bw,bh){
    const stepX=bw/cols, stepY=bh/rows;
    const gapRatio=0.12;
    const wTile=stepX*(1-gapRatio), hTile=stepY*(1-gapRatio);
    const gx=stepX-wTile, gy=stepY-hTile;
    const out=[]; let idx=0;
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const x=bx + c*stepX + gx*0.5;
        const y=by + r*stepY + gy*0.5;
        out.push({ x, y, w:wTile, h:hTile, row:r, col:c, index:idx++ });
      }
    }
    return out;
  }

  // Overlay sizing: match the video's on-screen box exactly
  function updateOverlayBox(){
    const v = video.getBoundingClientRect();
    const p = previewWrap.getBoundingClientRect();
    const left = v.left - p.left;
    const top = v.top - p.top;
    overlay.style.left = left+'px';
    overlay.style.top = top+'px';
    overlay.style.width = v.width+'px';
    overlay.style.height = v.height+'px';
    const w = Math.max(1, Math.round(v.width));
    const h = Math.max(1, Math.round(v.height));
    if (overlay.width !== w) overlay.width = w;
    if (overlay.height !== h) overlay.height = h;
  }

  // Draw overlay (board, tiles, editor visuals)
  function drawOverlay(extra){
    updateOverlayBox(); // keep overlay aligned to video box

    const vw = overlay.width, vh = overlay.height;
    ctxOv.clearRect(0,0,vw,vh);

    const scaleX = vw / (video.videoWidth||1);
    const scaleY = vh / (video.videoHeight||1);

    if (boardRect && video.videoWidth){
      ctxOv.save();
      ctxOv.strokeStyle='rgba(88,176,255,0.95)'; ctxOv.setLineDash([6,4]); ctxOv.lineWidth=2;
      ctxOv.strokeRect(boardRect.x*scaleX, boardRect.y*scaleY, boardRect.w*scaleX, boardRect.h*scaleY);
      ctxOv.restore();

      // Tiles
      ctxOv.save();
      ctxOv.strokeStyle='rgba(140,200,255,0.28)'; ctxOv.lineWidth=1;
      for (const t of tileRects){
        ctxOv.strokeRect(t.x*scaleX, t.y*scaleY, t.w*scaleX, t.h*scaleY);
      }
      ctxOv.restore();
    }

    // Editor visuals
    if (editor.mode === 'draw' && editor.rect){
      const r = editor.rect;
      ctxOv.save();
      ctxOv.setLineDash([8,6]); ctxOv.lineWidth=2; ctxOv.strokeStyle='rgba(88,176,255,0.95)';
      ctxOv.fillStyle='rgba(88,176,255,0.14)';
      const sq = squareFromRectCentered(r, vw, vh);
      ctxOv.fillRect(sq.x, sq.y, sq.w, sq.h);
      ctxOv.strokeRect(sq.x, sq.y, sq.w, sq.h);
      ctxOv.restore();
    }

    if (editor.mode === 'edit' && editor.rect){
      const r = editor.rect;
      ctxOv.save();
      ctxOv.setLineDash([8,6]); ctxOv.lineWidth=2; ctxOv.strokeStyle='rgba(88,176,255,0.95)';
      ctxOv.fillStyle='rgba(88,176,255,0.10)';
      ctxOv.fillRect(r.x, r.y, r.w, r.h);
      ctxOv.strokeRect(r.x, r.y, r.w, r.h);
      ctxOv.restore();

      // handles
      ctxOv.save();
      const hs = editor.handleSize;
      const handles = getHandleRects(r, hs);
      for (const hnd of handles){
        ctxOv.fillStyle = 'rgba(88,176,255,0.95)';
        ctxOv.fillRect(hnd.x, hnd.y, hnd.w, hnd.h);
        ctxOv.strokeStyle = '#0b1220';
        ctxOv.lineWidth = 1.5;
        ctxOv.strokeRect(hnd.x, hnd.y, hnd.w, hnd.h);
      }
      ctxOv.restore();
    }
  }

  function getHandleRects(r, hs){
    return [
      {name:'nw', x:r.x-hs/2, y:r.y-hs/2, w:hs, h:hs},
      {name:'ne', x:r.x+r.w-hs/2, y:r.y-hs/2, w:hs, h:hs},
      {name:'se', x:r.x+r.w-hs/2, y:r.y+r.h-hs/2, w:hs, h:hs},
      {name:'sw', x:r.x-hs/2, y:r.y+r.h-hs/2, w:hs, h:hs},
    ];
  }
  function hitTestHandle(x,y,r,hs){
    for (const h of getHandleRects(r,hs)){
      if (x>=h.x && x<=h.x+h.w && y>=h.y && y<=h.y+h.h) return h.name;
    }
    return null;
  }
  function pointInRect(x,y,r){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }

  function clamp(value,min,max){ return Math.max(min, Math.min(max, value)); }

  // Square helpers
  function squareFromRectCentered(r, maxW, maxH){
    // make a square centered on r, clamped to bounds
    const cx = r.x + r.w/2;
    const cy = r.y + r.h/2;
    const side = Math.min(Math.max(r.w,r.h), Math.min(maxW, maxH));
    let x = cx - side/2, y = cy - side/2;
    x = clamp(x, 0, maxW - side);
    y = clamp(y, 0, maxH - side);
    return { x, y, w: side, h: side };
    }
  function squareResizeFromCorner(startRect, handle, dx, dy, maxW, maxH){
    const minSide = 20;
    let side = startRect.w; // square
    let x = startRect.x;
    let y = startRect.y;
    // anchor per handle
    if (handle === 'se'){
      const desired = side + Math.max(dx, dy);
      const maxSide = Math.min(maxW - startRect.x, maxH - startRect.y);
      side = clamp(desired, minSide, maxSide);
      x = startRect.x; y = startRect.y;
    }else if (handle === 'ne'){
      const desired = side + Math.max(dx, -dy);
      const maxSide = Math.min(maxW - startRect.x, startRect.y + startRect.h);
      side = clamp(desired, minSide, maxSide);
      x = startRect.x; y = (startRect.y + startRect.h) - side;
      y = clamp(y, 0, maxH - side);
    }else if (handle === 'nw'){
      const desired = side + Math.max(-dx, -dy);
      const maxSide = Math.min(startRect.x + startRect.w, startRect.y + startRect.h);
      side = clamp(desired, minSide, maxSide);
      x = (startRect.x + startRect.w) - side;
      y = (startRect.y + startRect.h) - side;
      x = clamp(x, 0, maxW - side);
      y = clamp(y, 0, maxH - side);
    }else if (handle === 'sw'){
      const desired = side + Math.max(-dx, dy);
      const maxSide = Math.min(startRect.x + startRect.w, maxH - startRect.y);
      side = clamp(desired, minSide, maxSide);
      x = (startRect.x + startRect.w) - side;
      y = startRect.y;
      x = clamp(x, 0, maxW - side);
    }
    return { x, y, w: side, h: side };
  }
  function squareMove(startRect, dx, dy, maxW, maxH){
    const x = clamp(startRect.x + dx, 0, maxW - startRect.w);
    const y = clamp(startRect.y + dy, 0, maxH - startRect.h);
    return { x, y, w: startRect.w, h: startRect.h };
  }

  // Tile sampling / detection
  function ensureTileState(){
    tileState = tileRects.map(()=>({
      baseline:0, delta:0,
      energyBuf:new Float32Array(config.energyWindow), energySum:0, eIdx:0,
      hold:0, refractory:0, belowLow:true, lastHotTs:0
    }));
    sampleOffsets = tileRects.map((t)=>{
      const pts=[], insetX=t.w*0.15, insetY=t.h*0.15, wSpan=t.w*0.70, hSpan=t.h*0.70;
      for (let yi=0; yi<5; yi++){
        for (let xi=0; xi<5; xi++){
          pts.push([ insetX + wSpan*(xi/4), insetY + hSpan*(yi/4) ]);
        }
      }
      return pts;
    });
  }

  function isTealRGB(r,g,b){ return g>=96 && b>=96 && g>=1.25*r && b>=1.15*r && g<=1.6*b; }
  function isGreenRGB(r,g,b){ return g>=110 && g>=1.4*r && g>=1.25*b; }

  function calibrateBaselines(){
    if (!hasBoard) return;
    const data = readBoardImageData(); if (!data) return;
    for (let i=0;i<tileRects.length;i++){
      const t=tileRects[i]; const avgL=avgTileLuminance(data,t);
      const st=tileState[i]; st.baseline=avgL; st.delta=0; st.energyBuf.fill(0); st.energySum=0; st.eIdx=0;
      st.hold=0; st.refractory=0; st.belowLow=true;
    }
    warmupStartTs = performance.now();
  }

  function readBoardImageData(){
    if (!boardRect || !video.videoWidth) return null;
    work.width=Math.max(2, Math.floor(boardRect.w)); work.height=Math.max(2, Math.floor(boardRect.h));
    wctx.drawImage(video, boardRect.x, boardRect.y, boardRect.w, boardRect.h, 0,0, work.width, work.height);
    return wctx.getImageData(0,0,work.width,work.height);
  }
  function avgTileLuminance(img,t){
    const sx=work.width/boardRect.w, sy=work.height/boardRect.h, off=sampleOffsets[t.index];
    let sum=0;
    for (let i=0;i<off.length;i++){
      const ox=off[i][0]*sx + (t.x-boardRect.x)*sx, oy=off[i][1]*sy + (t.y-boardRect.y)*sy;
      const xi=Math.max(0,Math.min(work.width-1,ox|0)), yi=Math.max(0,Math.min(work.height-1,oy|0));
      const idx=(yi*work.width+xi)*4; sum += luminance(img.data[idx], img.data[idx+1], img.data[idx+2]);
    }
    return sum/off.length;
  }
  function classifyTileRGB(img,t){
    const sx=work.width/boardRect.w, sy=work.height/boardRect.h, off=sampleOffsets[t.index];
    let tealHits=0, greenHits=0;
    for (let i=0;i<off.length;i++){
      const ox=off[i][0]*sx + (t.x-boardRect.x)*sx, oy=off[i][1]*sy + (t.y-boardRect.y)*sy;
      const xi=Math.max(0,Math.min(work.width-1,ox|0)), yi=Math.max(0,Math.min(work.height-1,oy|0));
      const idx=(yi*work.width+xi)*4, r=img.data[idx], g=img.data[idx+1], b=img.data[idx+2];
      if (isTealRGB(r,g,b)) tealHits++; if (isGreenRGB(r,g,b)) greenHits++;
    }
    return { teal:tealHits>=3, green:greenHits>=3 };
  }
  function updateEnergy(tsNow,i,delta){
    const st=tileState[i]; const v=Math.max(0, delta-config.thrLow);
    const old=st.energyBuf[st.eIdx]; st.energyBuf[st.eIdx]=v; st.eIdx=(st.eIdx+1)%config.energyWindow; st.energySum+=v-old;
    const thr=(config.thrHigh-config.thrLow)*config.energyScale; return st.energySum>=thr;
  }

  function handleFSMFrame(tsNow, events){
    const surgeLimit=Math.floor(tileRects.length*config.surgeRejectPct);
    const total=events.reveals.length + events.inputs.length;
    if (total>surgeLimit){ return {hot:-1}; }

    let hot=-1;
    const inWarmup=(tsNow - warmupStartTs) < config.warmupMs;

    switch(phase){
      case 'idle': break;
      case 'armed':
        if (!inWarmup && config.requireColorToStartReveal && events.reveals.length>0){
          phase='reveal'; revealSeq=[]; inputSeq=[]; revealStartTs=tsNow; lastClusterTs=tsNow;
          for (const idx of events.reveals){ revealSeq.push(idx); tileState[idx].lastHotTs=tsNow; hot=idx; }
        }
        break;
      case 'reveal': {
        const hardElapsed=tsNow-revealStartTs, sinceCluster=tsNow-lastClusterTs;
        if (!inWarmup && events.reveals.length>0){
          for (const idx of events.reveals){ revealSeq.push(idx); tileState[idx].lastHotTs=tsNow; hot=idx; }
          lastClusterTs=tsNow;
        }
        if (revealSeq.length>=revealLenExpected || hardElapsed>=config.revealHardTimeoutMs || sinceCluster>=config.clusterGapMs){
          phase='waiting-input'; inputSeq=[]; inputStartTs=tsNow;
        }
        break;
      }
      case 'waiting-input': {
        const inputElapsed=tsNow-inputStartTs;
        if (!inWarmup && events.inputs.length>0){
          for (const idx of events.inputs){ inputSeq.push(idx); tileState[idx].lastHotTs=tsNow; hot=idx; }
        }
        if (inputSeq.length>=revealLenExpected){
          roundIndex+=1; revealLenExpected=3+(roundIndex); phase='rearming'; rearmTs=tsNow; revealSeq=[]; inputSeq=[];
        }else if (inputElapsed>=config.inputTimeoutMs){
          phase='rearming'; rearmTs=tsNow; revealSeq=[]; inputSeq=[];
        }
        break;
      }
      case 'rearming':
        if (tsNow - rearmTs >= config.rearmDelayMs){ phase='armed'; }
        break;
    }
    return { hot };
  }

  function processFrame(tsNow){
    if (!hasBoard || !detectionActive) return { hot:-1 };
    const img = readBoardImageData(); if (!img) return { hot:-1 };
    const teal=[], green=[];
    for (let i=0;i<tileRects.length;i++){
      const t=tileRects[i], st=tileState[i];
      const cls=classifyTileRGB(img,t);
      const avgL=avgTileLuminance(img,t);
      st.baseline = st.baseline*(1-config.emaAlpha) + avgL*config.emaAlpha;
      const delta = st.delta = avgL - st.baseline;

      const inWarmup=(tsNow - warmupStartTs) < config.warmupMs;
      if (inWarmup){ st.belowLow = delta<=config.thrLow; st.hold = (delta>=config.thrHigh)?Math.min(config.holdFrames, st.hold+1):0; continue; }

      if (delta<=config.thrLow){ st.belowLow=true; st.refractory=0; } else { st.belowLow=false; if (st.refractory>0) st.refractory--; }
      st.hold = (delta>=config.thrHigh)?Math.min(config.holdFrames, st.hold+1):0;
      const byHold=(st.hold>=config.holdFrames), byEnergy=updateEnergy(tsNow,i,delta);
      const canTrigger=(st.refractory===0)||st.belowLow;
      if (canTrigger && (byHold||byEnergy)){
        if (phase==='armed' || phase==='reveal'){ if (cls.teal){ teal.push(i); st.refractory=config.refractoryFrames; } }
        else if (phase==='waiting-input'){ if (cls.green){ green.push(i); st.refractory=config.refractoryFrames; } }
      }
    }
    return handleFSMFrame(tsNow, { reveals:teal, inputs:green });
  }

  // Loops
  function uiLoop(){
    if (!running){ return; }
    drawOverlay();
    requestAnimationFrame(uiLoop);
  }
  function videoLoopRaf(){
    if (!running){ return; }
    const tsNow=performance.now();
    framesInBucket++; if (tsNow-lastFPSTs>=1000){ elFPS.textContent=String(framesInBucket); framesInBucket=0; lastFPSTs=tsNow; }
    if (detectionActive){ const r=processFrame(tsNow); updateStatus(); renderSequence(); }
    requestAnimationFrame(videoLoopRaf);
  }
  function videoLoopVFC(now){
    if (!running){ return; }
    framesInBucket++; if (now-lastFPSTs>=1000){ elFPS.textContent=String(framesInBucket); framesInBucket=0; lastFPSTs=now; }
    if (detectionActive){ const r=processFrame(now); updateStatus(); renderSequence(); }
    video.requestVideoFrameCallback(videoLoopVFC);
  }
  function startLoops(){
    lastFPSTs=performance.now(); framesInBucket=0;
    requestAnimationFrame(uiLoop);
    if (typeof video.requestVideoFrameCallback==='function'){ video.requestVideoFrameCallback(videoLoopVFC); }
    else { requestAnimationFrame(videoLoopRaf); }
  }
  window.addEventListener('resize', updateOverlayBox);
  video.addEventListener('loadedmetadata', updateOverlayBox);
  video.addEventListener('play', updateOverlayBox);

  // Editor interactions
  function setOverlayPointer(on){
    overlay.classList.toggle('pe-auto', on);
    overlay.classList.toggle('pe-none', !on);
  }

  overlay.addEventListener('pointerdown', (e)=>{
    if (editor.mode==='idle') return;
    overlay.setPointerCapture(e.pointerId);
    const cr = overlay.getBoundingClientRect();
    const x = e.clientX - cr.left;
    const y = e.clientY - cr.top;
    editor.start = { x, y };
    if (editor.mode==='draw'){
      editor.rect = { x, y, w: 0, h: 0 };
    }else if (editor.mode==='edit'){
      const h = hitTestHandle(x, y, editor.rect, editor.handleSize);
      if (h){ editor.activeHandle = h; editor.rectStart = { ...editor.rect }; }
      else if (pointInRect(x,y,editor.rect)){ editor.activeHandle = 'move'; editor.rectStart = { ...editor.rect }; }
      else { editor.activeHandle = null; }
    }
    drawOverlay();
  });

  overlay.addEventListener('pointermove', (e)=>{
    if (editor.mode==='idle') return;
    const cr = overlay.getBoundingClientRect();
    const x = e.clientX - cr.left;
    const y = e.clientY - cr.top;
    const dx = x - editor.start.x;
    const dy = y - editor.start.y;
    const maxW = overlay.width, maxH = overlay.height;

    if (editor.mode==='draw' && editor.rect){
      editor.rect = clampRect(editor.start.x, editor.start.y, dx, dy, maxW, maxH);
    }else if (editor.mode==='edit' && editor.rect && editor.activeHandle){
      if (editor.activeHandle === 'move'){
        editor.rect = squareMove(editor.rectStart, dx, dy, maxW, maxH);
      }else{
        editor.rect = squareResizeFromCorner(editor.rectStart, editor.activeHandle, dx, dy, maxW, maxH);
      }
    }
    drawOverlay();
  });

  overlay.addEventListener('pointerup', ()=>{
    if (editor.mode==='draw' && editor.rect){
      // Snap to centered square and enter edit
      const sq = squareFromRectCentered(editor.rect, overlay.width, overlay.height);
      editor.rect = sq;
      editor.mode = 'edit';
      btnDoneEdit.disabled = false;
      drawOverlay();
    }else if (editor.mode==='edit'){
      editor.activeHandle = null;
      drawOverlay();
    }
  });
  overlay.addEventListener('pointercancel', ()=>{ editor.activeHandle=null; drawOverlay(); });

  // Keyboard nudges in edit mode
  window.addEventListener('keydown', (e)=>{
    if (editor.mode!=='edit' || !editor.rect) return;
    const step = e.shiftKey ? 10 : 1;
    let r = editor.rect;
    if (e.key==='ArrowLeft'){ r = squareMove(r, -step, 0, overlay.width, overlay.height); }
    else if (e.key==='ArrowRight'){ r = squareMove(r, step, 0, overlay.width, overlay.height); }
    else if (e.key==='ArrowUp'){ r = squareMove(r, 0, -step, overlay.width, overlay.height); }
    else if (e.key==='ArrowDown'){ r = squareMove(r, 0, step, overlay.width, overlay.height); }
    else if (e.key==='Escape'){ // cancel edit
      editor.mode='idle'; setOverlayPointer(false); btnDoneEdit.disabled=true;
    }
    editor.rect = r; drawOverlay();
  });

  function clampRect(x0,y0,dx,dy,maxW,maxH){
    const x1 = clamp(x0+dx, 0, maxW);
    const y1 = clamp(y0+dy, 0, maxH);
    const x = clamp(Math.min(x0,x1), 0, maxW);
    const y = clamp(Math.min(y0,y1), 0, maxH);
    const w = clamp(Math.abs(x1-x0), 0, maxW - x);
    const h = clamp(Math.abs(y1-y0), 0, maxH - y);
    return { x, y, w, h };
  }

  function commitEditorRectToBoard(){
    // Convert display to video coords and build tiles + calibrate
    if (!editor.rect || !video.videoWidth) return;
    const vw = overlay.width, vh = overlay.height;
    const scaleX = (video.videoWidth||1) / vw;
    const scaleY = (video.videoHeight||1) / vh;
    const r = editor.rect;
    boardRect = { x: r.x*scaleX, y: r.y*scaleY, w: r.w*scaleX, h: r.h*scaleY };
    tileRects = buildTilesFromSquare(boardRect.x, boardRect.y, boardRect.w, boardRect.h);
    hasBoard = true;
    ensureTileState();
    calibrateBaselines();
    btnEditBoard.disabled = false;
    btnClearBoard.disabled = true; // will enable after Done
  }

  // Events
  btnCapture.addEventListener('click', startCapture);
  btnStopCapture.addEventListener('click', ()=>{ stopCapture(); resetDetectionState({clearBoard:true}); });

  btnSetBoard.addEventListener('click', ()=>{
    if (!video.videoWidth){ alert('Start capture first.'); return; }
    editor.mode='draw'; editor.rect=null; setOverlayPointer(true); btnDoneEdit.disabled=true;
  });
  btnEditBoard.addEventListener('click', ()=>{
    if (!boardRect){ alert('Set the board first.'); return; }
    // Seed editor from current boardRect (convert to display)
    const vw=overlay.width, vh=overlay.height;
    const sx = vw/(video.videoWidth||1), sy = vh/(video.videoHeight||1);
    editor.rect = { x: boardRect.x*sx, y: boardRect.y*sy, w: boardRect.w*sx, h: boardRect.h*sy };
    editor.mode='edit'; setOverlayPointer(true); btnDoneEdit.disabled=false;
  });
  btnDoneEdit.addEventListener('click', ()=>{
    if (editor.mode!=='edit' || !editor.rect){ return; }
    commitEditorRectToBoard();
    editor.mode='idle'; setOverlayPointer(false); btnDoneEdit.disabled=true; btnClearBoard.disabled=false;
    drawOverlay();
  });
  btnClearBoard.addEventListener('click', ()=>{ resetDetectionState({clearBoard:true}); drawOverlay(); });

  btnCalibrate.addEventListener('click', ()=>{
    if (!hasBoard){ alert('Set the board first.'); return; }
    calibrateBaselines(); updateStatus();
  });

  btnStart.addEventListener('click', ()=>{
    if (!stream){ alert('Start capture first.'); return; }
    if (!hasBoard){ alert('Set the board first.'); return; }
    detectionActive=true; phase='armed'; warmupStartTs=performance.now();
    btnStart.disabled=true; btnStop.disabled=false; updateStatus();
  });
  btnStop.addEventListener('click', ()=>{ detectionActive=false; phase='idle'; btnStart.disabled=false; btnStop.disabled=true; updateStatus(); });

  selDifficulty.addEventListener('change', ()=>{ difficulty=selDifficulty.value; updateGridFromDifficulty(); resetDetectionState({clearBoard:true}); drawOverlay(); });
  btnRestoreDefaults.addEventListener('click', ()=>{ Object.assign(config, defaultConfig); createConfigGrid(); });

  // Init
  updateGridFromDifficulty(); createConfigGrid(); resetDetectionState({clearBoard:true});
  // Ensure overlay aligns if the video box changes layout
  const ro = new ResizeObserver(()=> updateOverlayBox());
  ro.observe(previewWrap);
})();
</script>
</body>
</html>