<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Zen Solver (New Engine)</title>
<style>
  :root{
    --navy-900:#0b1220; --navy-850:#0f1a2b; --navy-800:#122036; --navy-750:#152744;
    --blue-500:#3aa0ff; --blue-400:#58b0ff; --blue-300:#8cc8ff;
    --green-400:#38d677; --text-100:#e6eef7; --text-200:#c3d4ea; --muted-400:#7f9bb9;
    --card-radius:12px; --shadow:0 6px 18px rgba(0,0,0,.35); --mono:ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 800px at 20% 0%, var(--navy-800), var(--navy-900));
    color:var(--text-100); font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; line-height:1.4;
  }
  .app{display:grid; grid-template-columns:420px 1fr; gap:16px; padding:16px; height:100dvh}
  .card{
    background:linear-gradient(180deg, var(--navy-800), var(--navy-850));
    border:1px solid rgba(90,140,200,.15); border-radius:var(--card-radius); box-shadow:var(--shadow);
    overflow:hidden; display:flex; flex-direction:column;
  }
  .card-header{padding:12px 14px; border-bottom:1px solid rgba(120,170,230,.15); font-weight:600; color:var(--blue-300); display:flex; align-items:center; justify-content:space-between}
  .card-body{padding:14px; overflow:auto}
  .controls{display:grid; gap:12px}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  button,select{
    background:linear-gradient(180deg, var(--navy-750), var(--navy-800));
    border:1px solid rgba(80,130,200,.25); color:var(--text-100); border-radius:10px; padding:10px 12px; font-size:14px; cursor:pointer; transition:all .15s ease;
  }
  button:hover,select:hover{border-color:var(--blue-400); box-shadow:0 0 0 3px rgba(60,160,255,.15) inset}
  button.primary{background:linear-gradient(180deg,#0d2b4a,#0e2141); border-color:rgba(58,160,255,.7); color:var(--blue-300); font-weight:600}
  button.success{border-color:rgba(56,214,119,.6); color:var(--green-400)}
  button.ghost{border-color:rgba(120,170,230,.35); color:var(--text-200)}
  button:disabled{opacity:.55; cursor:not-allowed}
  label{display:block; margin-bottom:6px; color:var(--text-200)}
  input[type="number"], input[type="text"]{
    width:100%; padding:8px 10px; border-radius:8px;
    background:linear-gradient(180deg, var(--navy-750), var(--navy-800));
    border:1px solid rgba(80,130,200,.25); color:var(--text-100);
    font-variant-numeric: tabular-nums; font-family: var(--mono);
  }
  .status{display:grid; grid-template-columns:repeat(3, 1fr); gap:8px; margin-top:8px; font-family:var(--mono); font-variant-numeric:tabular-nums}
  .status div{padding:8px; background:linear-gradient(180deg, var(--navy-800), var(--navy-850)); border:1px solid rgba(90,140,200,.2); border-radius:8px; color:var(--text-200)}
  .status strong{color:var(--text-100)}
  .preview-wrap{position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:radial-gradient(800px 600px at 50% 0%, #0e1a2e, #0b1220)}
  video{max-width:100%; max-height:100%; border-radius:10px; border:1px solid rgba(80,130,200,.25); background:#000}
  canvas.overlay{
    position:absolute; z-index:3; touch-action:none; user-select:none; -webkit-user-select:none;
  }
  .overlay.pe-none{pointer-events:none}
  .overlay.pe-auto{pointer-events:auto}
  .guideHeader{
    position:absolute; left:12px; top:12px; padding:6px 10px; border-radius:10px;
    background:rgba(10,18,32,0.55); border:1px solid rgba(140,200,255,0.35); backdrop-filter: blur(4px);
    font-weight:600; color:#cfe6ff; z-index:4; pointer-events:none;
  }
  .engineBadge{
    position:absolute; right:12px; top:12px; z-index:4;
    padding:6px 10px; border-radius:10px; font-weight:700; letter-spacing:.3px;
    border:1px solid rgba(140,200,255,.35); background:rgba(10,18,32,.55); color:#caffdf
  }
  details {
    border:1px solid rgba(120,170,230,.15);
    border-radius:10px;
    padding:8px 10px;
    background:linear-gradient(180deg, var(--navy-800), var(--navy-850));
  }
  details > summary {
    cursor: pointer;
    list-style: none;
    color: var(--text-200);
    font-weight: 600;
  }
  details[open] { border-color: rgba(120,170,230,.35); }
  .legend{display:flex; gap:10px; flex-wrap:wrap; margin-top:6px; color:var(--muted-400); font-size:12px}
  .legend span{display:inline-flex; align-items:center; gap:6px}
  .legend .board{width:10px; height:10px; background:transparent; border:1px dashed #58b0ff; border-radius:2px}
  .legend .green{width:10px; height:10px; background:#22c55e; border-radius:2px}
  @media (max-width:1100px){.app{grid-template-columns:1fr; height:auto}.card-body{max-height:55vh}.preview-wrap{height:55vh}}
</style>
</head>
<body>
  <div class="app">
    <!-- Left: Controls -->
    <section class="card">
      <div class="card-header">
        <div>Controls</div>
        <div class="engineBadge">NEW</div>
      </div>
      <div class="card-body">
        <div class="controls">
          <div class="row">
            <button id="btnCapture" class="primary">Start Capture</button>
            <button id="btnStopCapture" class="ghost" disabled>Stop Capture</button>
          </div>

          <div class="row">
            <button id="btnSetBoard" class="ghost">Set Board</button>
            <button id="btnEditBoard" class="ghost" disabled>Edit Board</button>
            <button id="btnDoneEdit" class="success" disabled>Done</button>
            <button id="btnClearBoard" class="ghost" disabled>Clear</button>
          </div>

          <div class="row">
            <button id="btnStart" class="success" disabled>Start Detection</button>
            <button id="btnStop" class="ghost" disabled>Stop Detection</button>
            <button id="btnResetRounds" class="ghost" disabled>Reset Rounds</button>
          </div>

          <div>
            <label for="difficulty">Difficulty</label>
            <select id="difficulty">
              <option value="easy">Easy (4×4)</option>
              <option value="medium">Medium (5×5)</option>
              <option value="hard">Hard (6×6)</option>
              <option value="expert" selected>Expert (6×6)</option>
            </select>
            <div class="legend">
              <span><i class="board"></i> Board</span>
              <span><i class="green"></i> Next input highlight</span>
              <span>Grid preview appears while drawing/editing</span>
            </div>
          </div>

          <details id="advDetails">
            <summary>Advanced (collapsed)</summary>
            <div class="row" style="margin-top:8px; width:100%">
              <div style="flex:1; min-width:180px">
                <label>Reveal End Silence (ms)</label>
                <input id="inpRevealEndSilence" type="number" min="300" max="2000" step="25" />
              </div>
              <div style="flex:1; min-width:180px">
                <label>Input Timeout (ms)</label>
                <input id="inpInputTimeout" type="number" min="3000" max="30000" step="250" />
              </div>
            </div>
            <div class="row" style="margin-top:8px; width:100%">
              <div style="flex:1; min-width:180px">
                <label>Teal Mask (hex, e.g. ffff00)</label>
                <input id="inpTealMask" type="text" placeholder="ffff00" />
              </div>
              <div style="flex:1; min-width:180px">
                <label>Teal Key (hex, e.g. 84a000)</label>
                <input id="inpTealKey" type="text" placeholder="84a000" />
              </div>
              <div style="flex:1; min-width:180px">
                <label>Green Key (hex, e.g. 5cac24)</label>
                <input id="inpGreenKey" type="text" placeholder="5cac24" />
              </div>
            </div>
            <div class="row" style="margin-top:8px">
              <button id="btnRestoreDefaults" class="ghost">Restore Advanced Defaults</button>
            </div>
          </details>

          <div class="status" id="status">
            <div>FPS: <strong id="fps">0</strong></div>
            <div>Phase: <strong id="phase">idle</strong></div>
            <div>Round: <strong id="round">1</strong></div>
            <div>Reveal: <strong id="revealCount">0</strong></div>
            <div>Input: <strong id="inputCount">0</strong></div>
            <div>Grid: <strong id="gridSize">6×6</strong></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Right: Video + Overlay -->
    <section class="card">
      <div class="card-header">Preview</div>
      <div class="preview-wrap" id="previewWrap">
        <div id="guideHeader" class="guideHeader" style="display:none">Step 1 / 1</div>
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay" class="overlay pe-none"></canvas>
      </div>
    </section>
  </div>

<script>
(function(){
  // DOM
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const previewWrap = document.getElementById('previewWrap');
  const guideHeader = document.getElementById('guideHeader');
  const ctxOv = overlay.getContext('2d', { alpha: true });

  const btnCapture = document.getElementById('btnCapture');
  const btnStopCapture = document.getElementById('btnStopCapture');
  const btnSetBoard = document.getElementById('btnSetBoard');
  const btnEditBoard = document.getElementById('btnEditBoard');
  const btnDoneEdit = document.getElementById('btnDoneEdit');
  const btnClearBoard = document.getElementById('btnClearBoard');
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnResetRounds = document.getElementById('btnResetRounds');

  const selDifficulty = document.getElementById('difficulty');
  const advDetails = document.getElementById('advDetails');
  const inpRevealEndSilence = document.getElementById('inpRevealEndSilence');
  const inpInputTimeout = document.getElementById('inpInputTimeout');
  const inpTealMask = document.getElementById('inpTealMask');
  const inpTealKey = document.getElementById('inpTealKey');
  const inpGreenKey = document.getElementById('inpGreenKey');
  const btnRestoreDefaults = document.getElementById('btnRestoreDefaults');

  const elFPS = document.getElementById('fps');
  const elPhase = document.getElementById('phase');
  const elRound = document.getElementById('round');
  const elRevealCount = document.getElementById('revealCount');
  const elInputCount = document.getElementById('inputCount');
  const elGridSize = document.getElementById('gridSize');

  // Config (New engine only)
  const defaultConfig = {
    revealEndSilenceMs:700,
    inputTimeoutMs:12000,
    rearmDelayMs:120,
    // Modal color classifier
    modal: {
      dropMask: 0xfcfcfc,  // drop low 2 bits per channel
      tealMask: 0xffff00,  // mask for teal-ish band
      tealKey:  0x84a000,  // expected masked teal value (tune as needed)
      greenKey: 0x5cac24,  // exact green after dropMask (tune as needed)
      sampleGrid: 10       // 10x10 samples inside tile
    }
  };
  const config = JSON.parse(JSON.stringify(defaultConfig)); // deep-ish clone

  // Populate advanced inputs and wire changes
  function hex(v){ return (v>>>0).toString(16).padStart(6,'0'); }
  function parseHexInput(el, fallback){
    const s = (el.value||'').trim().replace(/^0x/,'').toLowerCase();
    if (!/^[0-9a-f]{6}$/.test(s)) return fallback;
    return parseInt(s, 16)>>>0;
  }
  function syncAdvancedUI(){
    inpRevealEndSilence.value = String(config.revealEndSilenceMs);
    inpInputTimeout.value = String(config.inputTimeoutMs);
    inpTealMask.value = hex(config.modal.tealMask);
    inpTealKey.value  = hex(config.modal.tealKey);
    inpGreenKey.value = hex(config.modal.greenKey);
  }
  inpRevealEndSilence.addEventListener('change', ()=>{ const v=+inpRevealEndSilence.value; if (Number.isFinite(v)) config.revealEndSilenceMs = Math.max(300, Math.min(2000, v)); });
  inpInputTimeout.addEventListener('change', ()=>{ const v=+inpInputTimeout.value; if (Number.isFinite(v)) config.inputTimeoutMs = Math.max(3000, Math.min(30000, v)); });
  inpTealMask.addEventListener('change', ()=>{ config.modal.tealMask = parseHexInput(inpTealMask, config.modal.tealMask); });
  inpTealKey.addEventListener('change',  ()=>{ config.modal.tealKey  = parseHexInput(inpTealKey,  config.modal.tealKey);  });
  inpGreenKey.addEventListener('change', ()=>{ config.modal.greenKey = parseHexInput(inpGreenKey, config.modal.greenKey); });
  btnRestoreDefaults.addEventListener('click', ()=>{
    Object.assign(config, JSON.parse(JSON.stringify(defaultConfig)));
    syncAdvancedUI();
  });

  // Difficulty/grid
  let difficulty='expert', rows=6, cols=6;
  function updateGridFromDifficulty(){
    switch(difficulty){
      case 'easy': rows=4; cols=4; break;
      case 'medium': rows=5; cols=5; break;
      case 'hard': case 'expert': rows=6; cols=6; break;
      default: rows=6; cols=6;
    }
    elGridSize.textContent = `${cols}×${rows}`;
  }

  // State
  let stream=null, running=false, detectionActive=false, hasBoard=false;

  let boardRect=null; // video coords
  let tileRects=[];

  // New engine: VideoFrame reader + modal color
  class FrameReader {
    constructor(){ this.buffer = new ArrayBuffer(0); this.u32 = new Uint32Array(this.buffer); this.w=0; this.h=0; this.supported = (typeof VideoFrame !== 'undefined'); }
    copy(video, rect){
      if (!this.supported) throw new Error('VideoFrame not supported');
      const frame = new VideoFrame(video);
      if (rect.width !== this.w || rect.height !== this.h){
        this.w = rect.width|0; this.h = rect.height|0;
        this.buffer = new ArrayBuffer(this.w * this.h * 4);
        this.u32 = new Uint32Array(this.buffer);
      }
      frame.copyTo(this.buffer, { rect, format: 'RGBX' });
      frame.close();
    }
  }
  const fr = new FrameReader();

  function modalTileColor(u32, w, t){
    // Sample inside tile in board-space (boardRect aligned with fr.w x fr.h)
    const x0 = Math.max(0, (t.x - boardRect.x)|0);
    const y0 = Math.max(0, (t.y - boardRect.y)|0);
    const tw = Math.max(1, t.w|0), th = Math.max(1, t.h|0);
    const insetX = (tw*0.15)|0, insetY = (th*0.15)|0;
    const spanX = Math.max(1,(tw*0.70)|0), spanY = Math.max(1,(th*0.70)|0);
    const N = config.modal.sampleGrid|0;
    const hist = new Map();
    let best = 0, bestCount = -1;
    for (let yi=0; yi<N; yi++){
      for (let xi=0; xi<N; xi++){
        const px = Math.min(fr.w-1, x0 + insetX + ((xi*spanX)/(N-1))|0);
        const py = Math.min(fr.h-1, y0 + insetY + ((yi*spanY)/(N-1))|0);
        const c = u32[px + py * w] & config.modal.dropMask;
        const v = (hist.get(c)||0)+1; hist.set(c, v);
        if (v > bestCount){ best = c; bestCount = v; }
      }
    }
    return { color: best, count: bestCount };
  }

  function perfClassifyTiles(){
    // Returns { bestTealIdx, bestGreenIdx }
    let bestTealIdx=-1, bestTealScore=-1, bestGreenIdx=-1, bestGreenScore=-1;
    for (let i=0;i<tileRects.length;i++){
      const t=tileRects[i];
      const { color, count } = modalTileColor(fr.u32, fr.w, t);
      const isTeal = ((color & config.modal.tealMask) === config.modal.tealKey);
      const isGreen = (color === config.modal.greenKey);
      if (isTeal && count > bestTealScore){ bestTealScore=count; bestTealIdx=i; }
      if (isGreen && count > bestGreenScore){ bestGreenScore=count; bestGreenIdx=i; }
    }
    return { bestTealIdx, bestGreenIdx };
  }

  // FSM
  let phase='idle';
  let roundIndex=0;
  let revealSeq=[];
  let inputSeq=[];
  let revealLenExpected=0;

  // Timing
  let lastTealTs=0;
  let inputStartTs=0, rearmTs=0;

  // FPS
  let lastFPSTs=0, framesInBucket=0, measuredFps=0;

  // Editor
  const editor = { mode:'idle', rect:null, activeHandle:null, start:{x:0,y:0}, rectStart:null, handleSize:12 };
  const pointerState = { active:false, id:-1 };

  // Utils
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  function updateStatus(){
    elPhase.textContent=phase;
    elRound.textContent=String(roundIndex+1);
    elRevealCount.textContent=String(revealSeq.length);
    elInputCount.textContent=String(inputSeq.length);
  }

  // Build tiles from square
  function buildTilesFromSquare(bx,by,bw,bh){
    const stepX=bw/cols, stepY=bh/rows;
    const gap=0.12;
    const wTile=stepX*(1-gap), hTile=stepY*(1-gap);
    const gx=stepX-wTile, gy=stepY-hTile;
    const out=[]; let idx=0;
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const x=bx + c*stepX + gx*0.5;
        const y=by + r*stepY + gy*0.5;
        out.push({ x,y,w:wTile,h:hTile,row:r,col:c,index:idx++ });
      }
    }
    return out;
  }

  // Overlay sizing
  function updateOverlayBox(){
    const v = video.getBoundingClientRect();
    const p = previewWrap.getBoundingClientRect();
    overlay.style.left = (v.left - p.left)+'px';
    overlay.style.top  = (v.top  - p.top )+'px';
    overlay.style.width = v.width+'px';
    overlay.style.height = v.height+'px';
    const w = Math.max(1, Math.round(v.width));
    const h = Math.max(1, Math.round(v.height));
    if (overlay.width !== w) overlay.width = w;
    if (overlay.height !== h) overlay.height = h;
  }
  function setOverlayPointer(on){
    overlay.classList.toggle('pe-auto', on);
    overlay.classList.toggle('pe-none', !on);
    overlay.style.cursor = on ? 'crosshair' : 'default';
  }

  // Draw grid helper (for live preview while drawing/editing and when board set)
  function drawGrid(x,y,w,h,sx,sy){
    const gx = x*sx, gy = y*sy, gw = w*sx, gh = h*sy;
    // Outer
    ctxOv.save();
    ctxOv.setLineDash([6,4]); ctxOv.lineWidth=2; ctxOv.strokeStyle='rgba(88,176,255,0.95)';
    ctxOv.strokeRect(gx, gy, gw, gh);
    ctxOv.restore();
    // Inner grid lines
    ctxOv.save();
    ctxOv.setLineDash([2,3]); ctxOv.lineWidth=1.25; ctxOv.strokeStyle='rgba(140,200,255,0.5)';
    const stepX = gw/cols, stepY = gh/rows;
    for (let c=1;c<cols;c++){ const xx = gx + c*stepX; ctxOv.beginPath(); ctxOv.moveTo(xx, gy); ctxOv.lineTo(xx, gy+gh); ctxOv.stroke(); }
    for (let r=1;r<rows;r++){ const yy = gy + r*stepY; ctxOv.beginPath(); ctxOv.moveTo(gx, yy); ctxOv.lineTo(gx+gw, yy); ctxOv.stroke(); }
    ctxOv.restore();
  }

  // Main overlay draw
  function drawOverlay(){
    updateOverlayBox();

    const vw=overlay.width, vh=overlay.height;
    ctxOv.clearRect(0,0,vw,vh);
    const sx = vw/(video.videoWidth||1), sy = vh/(video.videoHeight||1);

    // When board set, always show the grid on top (calm blue lines, no red flashes)
    if (boardRect && video.videoWidth){
      drawGrid(boardRect.x, boardRect.y, boardRect.w, boardRect.h, sx, sy);
    }

    // Step guide: only show next tile (calm green ring), never flash whole board red
    if (phase==='waiting-input' && revealSeq.length>0 && boardRect){
      const k = inputSeq.length; const N = revealLenExpected || revealSeq.length;
      guideHeader.style.display='block';
      guideHeader.textContent = `Step ${Math.min(k+1,N)} / ${N}`;

      const nextIdx = revealSeq[k] ?? null;
      const now = performance.now();
      const pulse = 0.5 + 0.5*Math.sin(now/180);
      if (nextIdx != null){
        const t = tileRects[nextIdx];
        if (t){
          const x=t.x*sx, y=t.y*sy, w=t.w*sx, h=t.h*sy;
          ctxOv.lineWidth = 3 + 2*pulse;
          ctxOv.strokeStyle = `rgba(34,197,94,${0.55 + 0.35*pulse})`; // green
          ctxOv.shadowColor = 'rgba(34,197,94,0.35)'; ctxOv.shadowBlur = 10*pulse;
          ctxOv.strokeRect(x,y,w,h);
        }
      }
    } else {
      guideHeader.style.display='none';
    }

    // Live board selection/edit preview (with grid visible as you draw)
    if ((editor.mode==='draw' || editor.mode==='edit') && editor.rect){
      const r = editor.rect;
      // In draw mode, enforce square centered from drag; in edit mode, draw current rect as-is
      let sq = r;
      if (editor.mode==='draw'){
        sq = squareFromRectCentered(r, vw, vh);
      }
      // Draw grid inside the provisional square
      const v2x = (video.videoWidth||1)/vw, v2y = (video.videoHeight||1)/vh;
      drawGrid(sq.x*v2x, sq.y*v2y, sq.w*v2x, sq.h*v2y, sx, sy); // convert to video coords then back to overlay scale for consistent lines

      // Edit handles (only in edit)
      if (editor.mode==='edit'){
        const hs=editor.handleSize;
        for (const h of getHandleRects(sq,hs)){
          ctxOv.fillStyle='rgba(88,176,255,0.95)'; ctxOv.fillRect(h.x,h.y,h.w,h.h);
          ctxOv.strokeStyle='#0b1220'; ctxOv.lineWidth=1.5; ctxOv.strokeRect(h.x,h.y,h.w,h.h);
        }
      }
    }
  }

  // Video frame loop: New engine only
  function processFrame(tsNow){
    if (!hasBoard || !detectionActive) return;
    if (!fr.supported) return;

    const rect = { x: boardRect.x|0, y: boardRect.y|0, width: boardRect.w|0, height: boardRect.h|0 };
    try { fr.copy(video, rect); } catch(_){ return; }

    const { bestTealIdx, bestGreenIdx } = perfClassifyTiles();

    switch(phase){
      case 'idle': break;

      case 'armed': {
        if (bestTealIdx >= 0){
          phase='reveal';
          revealSeq=[]; inputSeq=[]; revealLenExpected=0;
          lastTealTs = tsNow;
        }
        break;
      }

      case 'reveal': {
        // Record on change-edge: push last active tile when a new tile appears
        // We track last item implicitly as last element of revealSeq
        if (bestTealIdx >= 0){
          lastTealTs = tsNow;
          const last = revealSeq[revealSeq.length-1];
          if (last == null || last !== bestTealIdx){
            revealSeq.push(bestTealIdx);
            elRevealCount.textContent=String(revealSeq.length);
          }
        }
        // End-of-reveal silence
        if ((tsNow - lastTealTs) >= config.revealEndSilenceMs){
          if (revealSeq.length > 0){
            phase='waiting-input';
            inputSeq=[]; inputStartTs=tsNow;
            revealLenExpected = revealSeq.length;
            guideHeader.style.display='block';
            guideHeader.textContent = `Step 1 / ${revealLenExpected}`;
          } else {
            phase='rearming'; rearmTs=tsNow;
          }
        }
        break;
      }

      case 'waiting-input': {
        const expected = revealSeq[inputSeq.length] ?? -1;
        const inputElapsed = tsNow - inputStartTs;

        if (bestGreenIdx >= 0){
          if (bestGreenIdx === expected){
            if (inputSeq[inputSeq.length-1] !== expected){
              inputSeq.push(expected);
              elInputCount.textContent=String(inputSeq.length);
            }
          }
          // No red flash or stress indicators on mismatch by design
        }

        if (inputSeq.length >= revealLenExpected && revealLenExpected>0){
          roundIndex += 1;
          phase='rearming'; rearmTs=tsNow;
          revealSeq=[]; inputSeq=[]; revealLenExpected=0;
          guideHeader.style.display='none';
        } else if (inputElapsed >= config.inputTimeoutMs){
          phase='rearming'; rearmTs=tsNow; revealSeq=[]; inputSeq=[]; revealLenExpected=0; guideHeader.style.display='none';
        }
        break;
      }

      case 'rearming':
        if (tsNow - rearmTs >= config.rearmDelayMs){
          phase='armed';
        }
        break;
    }

    updateStatus();
  }

  // Helper: square geometry and edit handles
  function squareFromRectCentered(r,maxW,maxH){
    const cx=r.x+r.w/2, cy=r.y+r.h/2, side=Math.min(Math.max(r.w,r.h), Math.min(maxW,maxH));
    let x=cx-side/2, y=cy-side/2; x=clamp(x,0,maxW-side); y=clamp(y,0,maxH-side);
    return {x,y,w:side,h:side};
  }
  function getHandleRects(r,hs){
    return [
      {name:'nw', x:r.x-hs/2, y:r.y-hs/2, w:hs, h:hs},
      {name:'ne', x:r.x+r.w-hs/2, y:r.y-hs/2, w:hs, h:hs},
      {name:'se', x:r.x+r.w-hs/2, y:r.y+r.h-hs/2, w:hs, h:hs},
      {name:'sw', x:r.x-hs/2, y:r.y+r.h-hs/2, w:hs, h:hs},
    ];
  }
  function hitTestHandle(x,y,r,hs){ for (const h of getHandleRects(r,hs)){ if (x>=h.x&&x<=h.x+h.w&&y>=h.y&&y<=h.y+h.h) return h.name; } return null; }
  function pointInRect(x,y,r){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }
  function clampRect(x0,y0,dx,dy,maxW,maxH){
    const x1=clamp(x0+dx,0,maxW), y1=clamp(y0+dy,0,maxH);
    const x=clamp(Math.min(x0,x1),0,maxW), y=clamp(Math.min(y0,y1),0,maxH);
    const w=clamp(Math.abs(x1-x0),0,maxW-x), h=clamp(Math.abs(y1-y0),0,maxH-y);
    return {x,y,w,h};
  }
  function squareResizeFromCorner(startRect, handle, dx, dy, maxW, maxH){
    const minSide=20; let side=startRect.w, x=startRect.x, y=startRect.y;
    if (handle==='se'){ const desired=side+Math.max(dx,dy); const maxSide=Math.min(maxW-startRect.x, maxH-startRect.y); side=clamp(desired,minSide,maxSide); }
    else if (handle==='ne'){ const desired=side+Math.max(dx,-dy); const maxSide=Math.min(maxW-startRect.x, startRect.y+startRect.h); side=clamp(desired,minSide,maxSide); y=(startRect.y+startRect.h)-side; y=clamp(y,0,maxH-side); }
    else if (handle==='nw'){ const desired=side+Math.max(-dx,-dy); const maxSide=Math.min(startRect.x+startRect.w, startRect.y+startRect.h); side=clamp(desired,minSide,maxSide); x=(startRect.x+startRect.w)-side; y=(startRect.y+startRect.h)-side; x=clamp(x,0,maxW-side); y=clamp(y,0,maxH-side); }
    else if (handle==='sw'){ const desired=side+Math.max(-dx,dy); const maxSide=Math.min(startRect.x+startRect.w, maxH-startRect.y); side=clamp(desired,minSide,maxSide); x=(startRect.x+startRect.w)-side; x=clamp(x,0,maxW-side); }
    return {x,y,w:side,h:side};
  }
  function squareMove(startRect,dx,dy,maxW,maxH){
    const x=clamp(startRect.x+dx,0,maxW-startRect.w), y=clamp(startRect.y+dy,0,maxH-startRect.h);
    return {x,y,w:startRect.w,h:startRect.h};
  }
  function getOverlayXY(e){
    const cr = overlay.getBoundingClientRect();
    const cx = (e.clientX != null) ? e.clientX : (e.touches && e.touches[0]?.clientX) || 0;
    const cy = (e.clientY != null) ? e.clientY : (e.touches && e.touches[0]?.clientY) || 0;
    return { x: cx - cr.left, y: cy - cr.top };
  }

  // Overlay pointer handlers (robust, with mouse fallback)
  function onOverlayPointerDown(e){
    if (editor.mode === 'idle') return;
    e.preventDefault();
    if (overlay.width < 10 || overlay.height < 10) updateOverlayBox();

    pointerState.active = true;
    pointerState.id = e.pointerId ?? -1;
    try{ overlay.setPointerCapture && overlay.setPointerCapture(e.pointerId); }catch(_){}

    const { x, y } = getOverlayXY(e);
    editor.start = { x, y };

    if (editor.mode === 'draw'){
      editor.rect = { x, y, w: 0, h: 0 };
    } else if (editor.mode === 'edit'){
      const h = hitTestHandle(x,y,editor.rect,editor.handleSize);
      if (h){ editor.activeHandle = h; editor.rectStart = { ...editor.rect }; }
      else if (pointInRect(x,y,editor.rect)){ editor.activeHandle = 'move'; editor.rectStart = { ...editor.rect }; }
      else { editor.activeHandle = null; }
    }
    drawOverlay();
  }
  function onOverlayPointerMove(e){
    if (editor.mode === 'idle' || !pointerState.active) return;
    e.preventDefault();
    const { x, y } = getOverlayXY(e);
    const dx = x - editor.start.x, dy = y - editor.start.y;
    const maxW = overlay.width, maxH = overlay.height;

    if (editor.mode === 'draw' && editor.rect){
      editor.rect = clampRect(editor.start.x, editor.start.y, dx, dy, maxW, maxH);
    } else if (editor.mode === 'edit' && editor.rect && editor.activeHandle){
      if (editor.activeHandle === 'move') editor.rect = squareMove(editor.rectStart, dx, dy, maxW, maxH);
      else editor.rect = squareResizeFromCorner(editor.rectStart, editor.activeHandle, dx, dy, maxW, maxH);
    }
    drawOverlay();
  }
  function onOverlayPointerUp(e){
    if (!pointerState.active) return;
    pointerState.active = false;
    try{ overlay.releasePointerCapture && overlay.releasePointerCapture(e.pointerId); }catch(_){}

    if (editor.mode === 'draw' && editor.rect){
      editor.rect = squareFromRectCentered(editor.rect, overlay.width, overlay.height);
      editor.mode = 'edit';
      btnDoneEdit.disabled = false;
    } else if (editor.mode === 'edit'){
      editor.activeHandle = null;
    }
    drawOverlay();
  }

  overlay.addEventListener('pointerdown', onOverlayPointerDown, { passive:false });
  overlay.addEventListener('pointermove', onOverlayPointerMove, { passive:false });
  overlay.addEventListener('pointerup', onOverlayPointerUp, { passive:true });
  overlay.addEventListener('pointercancel', onOverlayPointerUp, { passive:true });
  overlay.addEventListener('mousedown', (e)=>{ if (!('pointerId' in e)) onOverlayPointerDown(e); }, { passive:false });
  window.addEventListener('mousemove', (e)=>{ if (pointerState.active && !('pointerId' in e)) onOverlayPointerMove(e); }, { passive:false });
  window.addEventListener('mouseup',   (e)=>{ if (pointerState.active && !('pointerId' in e)) onOverlayPointerUp(e); },   { passive:true });

  // Video loops (FPS + processing)
  function uiLoop(){ if (!running) return; drawOverlay(); requestAnimationFrame(uiLoop); }
  function videoLoopVFC(now){
    if (!running) return;
    framesInBucket++; if (now-lastFPSTs>=1000){ measuredFps=framesInBucket; elFPS.textContent=String(framesInBucket); framesInBucket=0; lastFPSTs=now; }
    if (detectionActive){ processFrame(now); }
    video.requestVideoFrameCallback(videoLoopVFC);
  }
  function videoLoopRaf(){
    if (!running) return;
    const tsNow=performance.now();
    framesInBucket++; if (tsNow-lastFPSTs>=1000){ measuredFps=framesInBucket; elFPS.textContent=String(framesInBucket); framesInBucket=0; lastFPSTs=tsNow; }
    if (detectionActive){ processFrame(tsNow); }
    requestAnimationFrame(videoLoopRaf);
  }
  function startLoops(){
    lastFPSTs=performance.now(); framesInBucket=0;
    requestAnimationFrame(uiLoop);
    if (typeof video.requestVideoFrameCallback==='function'){ video.requestVideoFrameCallback(videoLoopVFC); }
    else { requestAnimationFrame(videoLoopRaf); }
  }

  // Capture
  async function startCapture(){
    try{
      const streamLocal = await navigator.mediaDevices.getDisplayMedia({
        video:{ displaySurface:'window', frameRate:{ideal:60,max:60}, cursor:'never' }, audio:false
      });
      video.srcObject = streamLocal;
      const track = streamLocal.getVideoTracks()[0];
      try{ await track.applyConstraints({ frameRate:{ideal:60,max:60} }); }catch(_){}
      try{ if ('contentHint' in track) track.contentHint='motion'; }catch(_){}
      stream = streamLocal;
      btnCapture.disabled=true; btnStopCapture.disabled=false;
      btnSetBoard.disabled=false;
      running=true; startLoops();
    }catch(e){ console.error(e); alert('Screen/window capture was not granted.'); }
  }
  function stopCapture(){
    if (stream){ stream.getTracks().forEach(t=>t.stop()); }
    stream=null; video.srcObject=null; running=false;
    btnCapture.disabled=false; btnStopCapture.disabled=true;
    btnSetBoard.disabled=true;
    resetDetectionState({clearBoard:true});
    drawOverlay();
  }

  // Detection state resets
  function resetDetectionState({clearBoard=true}={}){
    detectionActive=false; btnStart.disabled=!hasBoard; btnStop.disabled=true; btnResetRounds.disabled=true;
    phase='idle'; roundIndex=0; revealSeq=[]; inputSeq=[]; revealLenExpected=0;
    lastTealTs=0; inputStartTs=0; rearmTs=0;
    guideHeader.style.display='none'; guideHeader.textContent='';
    if (clearBoard){
      boardRect=null; tileRects=[]; hasBoard=false;
      btnEditBoard.disabled=true; btnDoneEdit.disabled=true; btnClearBoard.disabled=true;
      Object.assign(editor,{mode:'idle',rect:null,activeHandle:null});
      setOverlayPointer(false);
    }
    updateStatus();
  }
  function resetRounds(){
    roundIndex=0; revealSeq=[]; inputSeq=[]; revealLenExpected=0;
    phase='armed';
    guideHeader.style.display='none'; guideHeader.textContent='';
    updateStatus();
  }

  // Commit board rect -> tiles
  function commitEditorRectToBoard(){
    if (!editor.rect || !video.videoWidth) return;
    const vw=overlay.width, vh=overlay.height, sx=(video.videoWidth||1)/vw, sy=(video.videoHeight||1)/vh;
    const r=editor.rect;
    boardRect={ x:r.x*sx, y:r.y*sy, w:r.w*sx, h:r.h*sy };
    tileRects = buildTilesFromSquare(boardRect.x,boardRect.y,boardRect.w,boardRect.h);
    hasBoard=true;
    btnEditBoard.disabled=false; btnClearBoard.disabled=false; btnStart.disabled=false; btnResetRounds.disabled=false;
  }

  // Events
  btnCapture.addEventListener('click', startCapture);
  btnStopCapture.addEventListener('click', stopCapture);

  btnSetBoard.addEventListener('click', ()=>{
    if (!video.videoWidth){ alert('Start capture first.'); return; }
    updateOverlayBox();
    pointerState.active = false;
    editor.mode='draw';
    editor.rect=null;
    setOverlayPointer(true);
    btnDoneEdit.disabled=true;
    drawOverlay();
  });
  btnEditBoard.addEventListener('click', ()=>{
    if (!boardRect){ alert('Set the board first.'); return; }
    updateOverlayBox();
    const vw=overlay.width, vh=overlay.height, sx=vw/(video.videoWidth||1), sy=vh/(video.videoHeight||1);
    editor.rect={ x:boardRect.x*sx, y:boardRect.y*sy, w:boardRect.w*sx, h:boardRect.h*sy };
    editor.mode='edit';
    pointerState.active = false;
    setOverlayPointer(true);
    btnDoneEdit.disabled=false;
    drawOverlay();
  });
  btnDoneEdit.addEventListener('click', ()=>{
    if (editor.mode==='edit'){
      commitEditorRectToBoard();
      editor.mode='idle';
      pointerState.active = false;
      setOverlayPointer(false);
      btnDoneEdit.disabled=true;
      drawOverlay();
    } else if (editor.mode==='draw' && editor.rect){
      // If user clicks Done while drawing, finalize current square
      editor.rect = squareFromRectCentered(editor.rect, overlay.width, overlay.height);
      commitEditorRectToBoard();
      editor.mode='idle';
      setOverlayPointer(false);
      btnDoneEdit.disabled=true;
      drawOverlay();
    }
  });
  btnClearBoard.addEventListener('click', ()=>{ resetDetectionState({clearBoard:true}); drawOverlay(); });

  btnStart.addEventListener('click', ()=>{
    if (!stream){ alert('Start capture first.'); return; }
    if (!hasBoard){ alert('Set the board first.'); return; }
    if (!fr.supported){ alert('New engine requires VideoFrame support (Chromium/WebCodecs).'); return; }
    detectionActive=true; phase='armed';
    btnStart.disabled=true; btnStop.disabled=false; btnResetRounds.disabled=false;
    updateStatus();
  });
  btnStop.addEventListener('click', ()=>{ detectionActive=false; phase='idle'; btnStart.disabled=false; btnStop.disabled=true; updateStatus(); });

  btnResetRounds.addEventListener('click', ()=>{ resetRounds(); });

  selDifficulty.addEventListener('change', ()=>{ difficulty=selDifficulty.value; updateGridFromDifficulty(); if (hasBoard){ // rebuild tiles to match rows/cols
      tileRects = buildTilesFromSquare(boardRect.x,boardRect.y,boardRect.w,boardRect.h);
      resetDetectionState({clearBoard:false});
    } drawOverlay(); });

  // Init
  updateGridFromDifficulty();
  syncAdvancedUI();
  resetDetectionState({clearBoard:true});

  // Link overlay sizing
  window.addEventListener('resize', updateOverlayBox);
  video.addEventListener('loadedmetadata', updateOverlayBox);
  video.addEventListener('play', updateOverlayBox);

  const ro = new ResizeObserver(()=> updateOverlayBox());
  ro.observe(previewWrap);

})();
</script>
</body>
</html>