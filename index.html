<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Zen Solver</title>
<style>
  :root{
    --navy-900:#0b1220; --navy-850:#0f1a2b; --navy-800:#122036; --navy-750:#152744;
    --blue-500:#3aa0ff; --blue-400:#58b0ff; --blue-300:#8cc8ff;
    --green-400:#38d677; --red-400:#ef4444;
    --text-100:#e6eef7; --text-200:#c3d4ea; --muted-400:#7f9bb9;
    --card-radius:12px; --shadow:0 6px 18px rgba(0,0,0,.35); --mono:ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 800px at 20% 0%, var(--navy-800), var(--navy-900));
    color:var(--text-100); font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; line-height:1.4;
  }
  .app{display:grid; grid-template-columns:440px 1fr; gap:16px; padding:16px; height:100dvh}
  .card{
    background:linear-gradient(180deg, var(--navy-800), var(--navy-850));
    border:1px solid rgba(90,140,200,.15); border-radius:var(--card-radius); box-shadow:var(--shadow);
    overflow:hidden; display:flex; flex-direction:column;
  }
  .card-header{padding:12px 14px; border-bottom:1px solid rgba(120,170,230,.15); font-weight:600; color:var(--blue-300); display:flex; align-items:center; justify-content:space-between}
  .card-body{padding:14px; overflow:auto}
  .controls{display:grid; gap:12px}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  button,select,input[type="checkbox"]{
    background:linear-gradient(180deg, var(--navy-750), var(--navy-800));
    border:1px solid rgba(80,130,200,.25); color:var(--text-100); border-radius:10px; padding:10px 12px; font-size:14px; cursor:pointer; transition:all .15s ease;
  }
  input[type="checkbox"]{ width:auto; padding:8px; border-radius:6px; }
  button:hover,select:hover{border-color:var(--blue-400); box-shadow:0 0 0 3px rgba(60,160,255,.15) inset}
  button.primary{background:linear-gradient(180deg,#0d2b4a,#0e2141); border-color:rgba(58,160,255,.7); color:var(--blue-300); font-weight:600}
  button.success{border-color:rgba(56,214,119,.6); color:var(--green-400)}
  button.warn{border-color:rgba(255,107,107,.5); color:#ff9b9b}
  button.ghost{border-color:rgba(120,170,230,.35); color:var(--text-200)}
  button:disabled{opacity:.55; cursor:not-allowed}
  label{display:block; margin-bottom:6px; color:var(--text-200)}
  input[type="number"]{
    width:100%; padding:8px 10px; border-radius:8px;
    background:linear-gradient(180deg, var(--navy-750), var(--navy-800));
    border:1px solid rgba(80,130,200,.25); color:var(--text-100);
    font-variant-numeric: tabular-nums; font-family: var(--mono);
  }
  .status{display:grid; grid-template-columns:repeat(3, 1fr); gap:8px; margin-top:8px; font-family:var(--mono); font-variant-numeric:tabular-nums}
  .status div{padding:8px; background:linear-gradient(180deg, var(--navy-800), var(--navy-850)); border:1px solid rgba(90,140,200,.2); border-radius:8px; color:var(--text-200)}
  .status strong{color:var(--text-100)}
  .preview-wrap{position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:radial-gradient(800px 600px at 50% 0%, #0e1a2e, #0b1220)}
  video{max-width:100%; max-height:100%; border-radius:10px; border:1px solid rgba(80,130,200,.25); background:#000}
  canvas.overlay{
    position:absolute;
    z-index:3;           /* above video */
    touch-action:none;   /* avoid touch gestures eating pointer events */
  }
  .overlay.pe-none{pointer-events:none}
  .overlay.pe-auto{pointer-events:auto}
  .grid{display:grid; gap:10px}
  .grid.cols-2{grid-template-columns:1fr 1fr}
  .grid.cols-3{grid-template-columns:1fr 1fr 1fr}
  .divider{height:1px; background:linear-gradient(90deg, transparent, rgba(130,160,210,.25), transparent); margin:8px 0}
  .badge{display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; border:1px solid rgba(90,140,200,.25); color:var(--text-200); font-size:12px; background:linear-gradient(180deg, var(--navy-800), var(--navy-850))}
  .badge .dot{width:8px; height:8px; border-radius:50%; background:var(--blue-500)}
  .legend{display:flex; gap:10px; flex-wrap:wrap; margin-top:6px; color:var(--muted-400); font-size:12px}
  .legend span{display:inline-flex; align-items:center; gap:6px}
  .legend .teal{width:10px; height:10px; background:#2dd4d4; border-radius:2px}
  .legend .green{width:10px; height:10px; background:#22c55e; border-radius:2px}
  .legend .board{width:10px; height:10px; background:transparent; border:1px dashed #58b0ff; border-radius:2px}
  .guideHeader{
    position:absolute; left:12px; top:12px; padding:6px 10px; border-radius:10px;
    background:rgba(10,18,32,0.55); border:1px solid rgba(140,200,255,0.35); backdrop-filter: blur(4px);
    font-weight:600; color:#cfe6ff; z-index:2; pointer-events:none;
  }
  .debugCanvas{
    width:100%; height:auto; background:#0b1220; border:1px solid rgba(90,140,200,.2); border-radius:8px;
  }
  @media (max-width:1100px){.app{grid-template-columns:1fr; height:auto}.card-body{max-height:55vh}.preview-wrap{height:55vh}}
</style>
</head>
<body>
  <div class="app">
    <!-- Left: Controls + Debug -->
    <section class="card">
      <div class="card-header">
        <div>Controls</div>
        <div class="badge"><span class="dot"></span> Zen Solver</div>
      </div>
      <div class="card-body">
        <div class="controls">
          <div class="row">
            <button id="btnCapture" class="primary">Start Capture</button>
            <button id="btnStopCapture" class="warn" disabled>Stop Capture</button>
          </div>

          <div class="row">
            <button id="btnSetBoard" class="ghost">Set Board</button>
            <button id="btnEditBoard" class="ghost" disabled>Edit Board</button>
            <button id="btnDoneEdit" class="success" disabled>Done</button>
            <button id="btnClearBoard" class="ghost" disabled>Clear</button>
          </div>

          <div class="row">
            <button id="btnCalibrate" class="">Calibrate</button>
            <button id="btnStart" class="success">Start Detection</button>
            <button id="btnStop" class="warn" disabled>Stop Detection</button>
            <button id="btnResetRounds" class="">Reset Rounds</button>
          </div>

          <div class="divider"></div>

          <div>
            <label for="difficulty">Difficulty</label>
            <select id="difficulty">
              <option value="easy">Easy (4×4)</option>
              <option value="medium">Medium (5×5)</option>
              <option value="hard">Hard (6×6)</option>
              <option value="expert" selected>Expert (6×6)</option>
            </select>
            <div class="legend">
              <span><i class="board"></i> Board</span>
              <span><i class="teal"></i> Teal (Reveal)</span>
              <span><i class="green"></i> Green (Input)</span>
              <span>Guide shows only the next tile</span>
            </div>
          </div>

          <div class="divider"></div>

          <div>
            <div style="display:flex;align-items:center;justify-content:space-between">
              <label>Timing</label>
              <button id="btnTimingDefaults" title="Restore Timing Defaults">Restore Timing Defaults</button>
            </div>
            <div class="grid cols-2" id="timingGrid"></div>
          </div>

          <div class="divider"></div>

          <div>
            <div style="display:flex;align-items:center;justify-content:space-between">
              <label>Debug</label>
              <div class="row" style="gap:8px">
                <label style="margin:0;display:flex;align-items:center;gap:6px"><input type="checkbox" id="ckDebug" /> Enable</label>
              </div>
            </div>
            <div class="grid cols-3" id="debugToggles">
              <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="ckDbgHeat" /> Overlay Heatmap</label>
              <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="ckDbgSamples" /> Overlay Samples</label>
              <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="ckDbgLabels" /> Overlay Labels</label>
            </div>
            <div class="row" style="gap:10px;align-items:center;margin-top:6px">
              <label style="display:flex;align-items:center;gap:6px;margin:0"><input type="checkbox" id="ckIgnoreCursor" checked /> Ignore Cursor</label>
              <label style="display:flex;align-items:center;gap:6px;margin:0"><input type="checkbox" id="ckIgnoreNearMouse" checked /> Mask Near Mouse</label>
              <label style="margin:0;display:flex;align-items:center;gap:6px">Radius
                <input type="number" id="inpCursorRadius" min="4" max="40" step="1" value="12" style="width:72px" />
              </label>
            </div>
            <div class="row" style="align-items:center">
              <label style="margin:0">Viewer</label>
              <select id="selDbgView">
                <option value="raw">Raw</option>
                <option value="grayscale">Grayscale L</option>
                <option value="delta">Delta Heatmap</option>
                <option value="teal">Teal Mask</option>
                <option value="green">Green Mask</option>
              </select>
            </div>
            <canvas id="debugView" class="debugCanvas" width="384" height="384"></canvas>
            <div class="legend" style="margin-top:6px">
              <span>Delta: +hot = yellow/red, -cool = blue</span>
              <span>Teal/Green masks show tile-level hit ratio</span>
            </div>
          </div>

          <div class="divider"></div>

          <div class="status" id="status">
            <div>FPS: <strong id="fps">0</strong></div>
            <div>Phase: <strong id="phase">idle</strong></div>
            <div>Round: <strong id="round">1</strong></div>
            <div>Reveal: <strong id="revealCount">0</strong></div>
            <div>Input: <strong id="inputCount">0</strong></div>
            <div>Grid: <strong id="gridSize">6×6</strong></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Center: Video + Overlay -->
    <section class="card">
      <div class="card-header">Preview</div>
      <div class="preview-wrap" id="previewWrap">
        <div id="guideHeader" class="guideHeader" style="display:none">Step 1 / 1</div>
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay" class="overlay pe-none"></canvas>
      </div>
    </section>
  </div>

<script>
(function(){
  // DOM
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const previewWrap = document.getElementById('previewWrap');
  const guideHeader = document.getElementById('guideHeader');
  const ctxOv = overlay.getContext('2d', { alpha: true });

  const btnCapture = document.getElementById('btnCapture');
  const btnStopCapture = document.getElementById('btnStopCapture');
  const btnSetBoard = document.getElementById('btnSetBoard');
  const btnEditBoard = document.getElementById('btnEditBoard');
  const btnDoneEdit = document.getElementById('btnDoneEdit');
  const btnClearBoard = document.getElementById('btnClearBoard');
  const btnCalibrate = document.getElementById('btnCalibrate');
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnResetRounds = document.getElementById('btnResetRounds');

  const selDifficulty = document.getElementById('difficulty');
  const btnTimingDefaults = document.getElementById('btnTimingDefaults');
  const timingGrid = document.getElementById('timingGrid');

  const ckDebug = document.getElementById('ckDebug');
  const ckDbgHeat = document.getElementById('ckDbgHeat');
  const ckDbgSamples = document.getElementById('ckDbgSamples');
  const ckDbgLabels = document.getElementById('ckDbgLabels');
  const ckIgnoreCursor = document.getElementById('ckIgnoreCursor');
  const ckIgnoreNearMouse = document.getElementById('ckIgnoreNearMouse');
  const inpCursorRadius = document.getElementById('inpCursorRadius');
  const selDbgView = document.getElementById('selDbgView');
  const debugView = document.getElementById('debugView');
  const ctxDbg = debugView.getContext('2d', { alpha: false });

  const elFPS = document.getElementById('fps');
  const elPhase = document.getElementById('phase');
  const elRound = document.getElementById('round');
  const elRevealCount = document.getElementById('revealCount');
  const elInputCount = document.getElementById('inputCount');
  const elGridSize = document.getElementById('gridSize');

  // Stable defaults + Min Split (for ordering) + Cursor suppression
  const defaultConfig = {
    thrHigh:10, thrLow:6, holdFrames:1, refractoryFrames:6, emaAlpha:0.20,
    energyWindow:5, energyScale:2.5, warmupMs:450, surgeRejectPct:0.4,
    revealStepGapMs:140,
    revealEndSilenceMs:700,
    minStepSplitMs:90,          // adaptive split threshold
    dedupeMs:160,
    belowLowFramesToBypass:2,
    inputTimeoutMs:12000,
    rearmDelayMs:120,
    requireColorToStartReveal:true,
    // Cursor suppression
    ignoreCursor:true,
    ignoreNearMouse:true,
    cursorWhiteSatMax:0.16,
    cursorWhiteVMin:0.88,
    cursorMaskRadiusPx:12,     // in work-canvas pixels
    cursorMaskRecentMs:120
  };
  const config = { ...defaultConfig };

  // Debug state
  const debug = {
    enabled: false,
    overlayHeatmap: false,
    overlaySamples: false,
    overlayLabels: false,
    view: 'raw'
  };

  // Mouse tracking for cursor masking (overlay + work coords)
  let lastMouse = { xOverlay:-1, yOverlay:-1, xWork:-1, yWork:-1, inBoard:false, ts:0 };
  function updateLastMouseFromEvent(e){
    const now = performance.now();
    const cr = overlay.getBoundingClientRect();
    const xo = e.clientX - cr.left;
    const yo = e.clientY - cr.top;

    // overlay -> video px
    const sxV = (video.videoWidth||1) / overlay.width;
    const syV = (video.videoHeight||1) / overlay.height;
    const xv = xo * sxV, yv = yo * syV;

    // video -> board -> work
    let inBoard=false, xw=-1, yw=-1;
    if (boardRect && work.width>0 && work.height>0){
      const xb = xv - boardRect.x, yb = yv - boardRect.y;
      if (xb>=0 && yb>=0 && xb<=boardRect.w && yb<=boardRect.h){
        const sxW = work.width / boardRect.w;
        const syW = work.height / boardRect.h;
        xw = xb * sxW; yw = yb * syW;
        inBoard = true;
      }
    }
    lastMouse = { xOverlay:xo, yOverlay:yo, xWork:xw, yWork:yw, inBoard, ts:now };
  }
  previewWrap.addEventListener('pointermove', updateLastMouseFromEvent, { passive:true });
  previewWrap.addEventListener('pointerenter', updateLastMouseFromEvent, { passive:true });
  previewWrap.addEventListener('pointerleave', ()=>{ lastMouse.inBoard=false; }, { passive:true });

  // Defaults
  let difficulty='expert', rows=6, cols=6;

  // State
  let stream=null, track=null, running=false, detectionActive=false, hasBoard=false;

  let boardRect=null; // video coords
  let tileRects=[];

  const work = document.createElement('canvas'); // board-only frame
  const wctx = work.getContext('2d', { willReadFrequently:true });

  let tileState=[], sampleOffsets=[];
  let tileMetrics=[]; // per-tile debug metrics

  // FSM
  let phase='idle'; // 'idle'|'armed'|'reveal'|'waiting-input'|'rearming'
  let roundIndex=0;
  let revealSeq=[];       // steps captured
  let inputSeq=[];        // accepted inputs (strict order)
  let revealLenExpected=0;

  // Timing marks
  let warmupStartTs=0, inputStartTs=0, rearmTs=0;

  // Reveal clusterer
  let stepCluster=null;   // { startTs, tally: Map, firstSeen: Map, leadIdx }
  let lastTealTs=0;

  // FPS
  let lastFPSTs=0, framesInBucket=0;

  // Wrong press flash
  let badPressTs=0, badPressTile=-1;

  // Editor
  const editor = { mode:'idle', rect:null, activeHandle:null, start:{x:0,y:0}, rectStart:null, handleSize:12 };

  // Helpers
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function luminance(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }

  // Overlay sizing: match the video box
  function updateOverlayBox(){
    const v = video.getBoundingClientRect();
    const p = previewWrap.getBoundingClientRect();
    overlay.style.left = (v.left - p.left)+'px';
    overlay.style.top  = (v.top  - p.top )+'px';
    overlay.style.width = v.width+'px';
    overlay.style.height = v.height+'px';
    const w = Math.max(1, Math.round(v.width));
    const h = Math.max(1, Math.round(v.height));
    if (overlay.width !== w) overlay.width = w;
    if (overlay.height !== h) overlay.height = h;
  }

  // Pointer toggling for overlay
  function setOverlayPointer(on){
    overlay.classList.toggle('pe-auto', on);
    overlay.classList.toggle('pe-none', !on);
    overlay.style.cursor = on ? 'crosshair' : 'default';
  }

  // Grid + UI
  function updateGridFromDifficulty(){
    switch(difficulty){
      case 'easy': rows=4; cols=4; break;
      case 'medium': rows=5; cols=5; break;
      case 'hard': case 'expert': rows=6; cols=6; break;
      default: rows=6; cols=6;
    }
    elGridSize.textContent = `${cols}×${rows}`;
  }
  function updateStatus(){
    elPhase.textContent=phase;
    elRound.textContent=String(roundIndex+1);
    elRevealCount.textContent=String(revealSeq.length);
    elInputCount.textContent=String(inputSeq.length);
  }
  function resetDetectionState({clearBoard=true}={}){
    detectionActive=false; btnStart.disabled=false; btnStop.disabled=true;
    phase='idle'; roundIndex=0; revealSeq=[]; inputSeq=[]; revealLenExpected=0;
    warmupStartTs=performance.now();
    stepCluster=null; lastTealTs=0; badPressTs=0; badPressTile=-1;
    guideHeader.style.display='none'; guideHeader.textContent='';
    tileMetrics=[];
    if (clearBoard){
      boardRect=null; tileRects=[]; tileState=[]; sampleOffsets=[]; hasBoard=false;
      btnEditBoard.disabled=true; btnDoneEdit.disabled=true; btnClearBoard.disabled=true;
      Object.assign(editor,{mode:'idle',rect:null,activeHandle:null});
    }
    setOverlayPointer(false);
    updateStatus();
  }
  function resetRounds(){
    roundIndex=0; revealSeq=[]; inputSeq=[]; revealLenExpected=0;
    phase='armed'; warmupStartTs=performance.now(); stepCluster=null; lastTealTs=0;
    guideHeader.style.display='none'; guideHeader.textContent='';
    updateStatus();
  }

  // Build tiles
  function buildTilesFromSquare(bx,by,bw,bh){
    const stepX=bw/cols, stepY=bh/rows;
    const gap=0.12;
    const wTile=stepX*(1-gap), hTile=stepY*(1-gap);
    const gx=stepX-wTile, gy=stepY-hTile;
    const out=[]; let idx=0;
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const x=bx + c*stepX + gx*0.5;
        const y=by + r*stepY + gy*0.5;
        out.push({ x,y,w:wTile,h:hTile,row:r,col:c,index:idx++ });
      }
    }
    return out;
  }

  // Sampling layout
  function ensureTileState(){
    tileState = tileRects.map(()=>({
      baseline:0, delta:0,
      energyBuf:new Float32Array(config.energyWindow), energySum:0, eIdx:0,
      hold:0, refractory:0, lowCount:0, belowLow:true,
      lastHotTs:0
    }));
    sampleOffsets = tileRects.map((t)=>{
      const pts=[], insetX=t.w*0.15, insetY=t.h*0.15, wSpan=t.w*0.70, hSpan=t.h*0.70;
      for (let yi=0; yi<5; yi++){ for (let xi=0; xi<5; xi++){ pts.push([insetX+wSpan*(xi/4), insetY+hSpan*(yi/4)]); } }
      return pts;
    });
  }

  // Color heuristics
  function isTealRGB(r,g,b){ return g>=96 && b>=96 && g>=1.25*r && b>=1.15*r && g<=1.6*b; }
  function isGreenRGB(r,g,b){ return g>=110 && g>=1.4*r && g>=1.25*b; }
  function rgbToHsv(r,g,b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
    let h=0;
    if (d!==0){
      if (max===r) h=((g-b)/d)%6;
      else if (max===g) h=(b-r)/d+2;
      else h=(r-g)/d+4;
      h*=60; if (h<0) h+=360;
    }
    const s=max===0?0:d/max, v=max;
    return [h,s,v];
  }

  function readBoardImageData(){
    if (!boardRect || !video.videoWidth) return null;
    work.width=Math.max(2,Math.floor(boardRect.w)); work.height=Math.max(2,Math.floor(boardRect.h));
    wctx.drawImage(video, boardRect.x,boardRect.y,boardRect.w,boardRect.h, 0,0, work.width,work.height);
    return wctx.getImageData(0,0,work.width,work.height);
  }
  function avgTileLuminance(img,t){
    const sx=work.width/boardRect.w, sy=work.height/boardRect.h, off=sampleOffsets[t.index];
    let sum=0;
    for (let i=0;i<off.length;i++){
      const ox=off[i][0]*sx + (t.x-boardRect.x)*sx, oy=off[i][1]*sy + (t.y-boardRect.y)*sy;
      const xi=Math.max(0,Math.min(work.width-1,ox|0)), yi=Math.max(0,Math.min(work.height-1,oy|0));
      const idx=(yi*work.width+xi)*4; sum += luminance(img.data[idx], img.data[idx+1], img.data[idx+2]);
    }
    return sum/off.length;
  }

  // Cursor-aware classification
  function classifyTileRGBWithCounts(img,t){
    const sx=work.width/boardRect.w, sy=work.height/boardRect.h, off=sampleOffsets[t.index];
    const now = performance.now();
    const useNearMouse = config.ignoreNearMouse && lastMouse.inBoard && ((now - lastMouse.ts) <= config.cursorMaskRecentMs);
    const r2 = config.cursorMaskRadiusPx * config.cursorMaskRadiusPx;

    let tealHits=0, greenHits=0;
    for (let i=0;i<off.length;i++){
      // work-space coords for this sample
      const ox=off[i][0]*sx + (t.x-boardRect.x)*sx;
      const oy=off[i][1]*sy + (t.y-boardRect.y)*sy;

      // Optional near-mouse mask
      if (useNearMouse){
        const dx = ox - lastMouse.xWork;
        const dy = oy - lastMouse.yWork;
        if ((dx*dx + dy*dy) <= r2) continue;
      }

      const xi=Math.max(0,Math.min(work.width-1,ox|0)), yi=Math.max(0,Math.min(work.height-1,oy|0));
      const idx=(yi*work.width+xi)*4, r=img.data[idx], g=img.data[idx+1], b=img.data[idx+2];

      // Optional near-white (cursor-like) suppression
      if (config.ignoreCursor){
        const [h,s,v]=rgbToHsv(r,g,b);
        if (s <= config.cursorWhiteSatMax && v >= config.cursorWhiteVMin){
          continue; // skip likely pointer/white glare
        }
      }

      // Existing color hits
      if (isTealRGB(r,g,b)) tealHits++;
      if (isGreenRGB(r,g,b)) greenHits++;
    }
    return { tealHits, greenHits, teal: tealHits>=3, green: greenHits>=3 };
  }

  function updateEnergy(tsNow,i,delta){
    const st=tileState[i]; const v=Math.max(0, delta-config.thrLow);
    const old=st.energyBuf[st.eIdx]; st.energyBuf[st.eIdx]=v; st.eIdx=(st.eIdx+1)%config.energyWindow; st.energySum+=v-old;
    const thr=(config.thrHigh-config.thrLow)*config.energyScale; return st.energySum>=thr;
  }

  // Reveal clustering (single-winner + earliest-wins + adaptive split)
  function addToCluster(tsNow, indices){
    if (!indices || indices.length===0) return;
    const idx = indices[0]; // single-winner per frame
    if (!stepCluster){
      stepCluster = { startTs: tsNow, tally: new Map(), firstSeen: new Map(), leadIdx: idx };
    }
    // Adaptive split
    if (stepCluster.leadIdx !== idx && (tsNow - stepCluster.startTs) >= config.minStepSplitMs){
      finalizeCluster(tsNow);
      stepCluster = { startTs: tsNow, tally: new Map(), firstSeen: new Map(), leadIdx: idx };
    }
    stepCluster.tally.set(idx, (stepCluster.tally.get(idx)||0)+1);
    if (!stepCluster.firstSeen.has(idx)) stepCluster.firstSeen.set(idx, tsNow);
    lastTealTs = tsNow;
  }
  function finalizeCluster(tsNow){
    if (!stepCluster) return -1;
    // Earliest-wins, fallback to most-votes
    let bestIdx=-1, bestTs=Infinity, bestCount=-1;
    for (const [idx, ts] of stepCluster.firstSeen.entries()){
      if (ts < bestTs){ bestTs = ts; bestIdx = idx; }
    }
    if (bestIdx < 0){
      for (const [idx, count] of stepCluster.tally){
        if (count > bestCount){ bestCount = count; bestIdx = idx; }
      }
    }
    stepCluster = null;
    if (bestIdx >= 0){
      const st=tileState[bestIdx];
      const within = st && ((tsNow - st.lastHotTs) < config.dedupeMs);
      if (!within){
        revealSeq.push(bestIdx);
        if (st) st.lastHotTs = tsNow;
        elRevealCount.textContent=String(revealSeq.length);
        return bestIdx;
      }
    }
    return -1;
  }
  function maybeFinalizeCluster(tsNow){
    if (!stepCluster) return -1;
    if ((tsNow - lastTealTs) >= config.revealStepGapMs){
      return finalizeCluster(tsNow);
    }
    return -1;
  }
  function shouldEndReveal(tsNow){
    return (revealSeq.length>0) && !stepCluster && ((tsNow - lastTealTs) >= config.revealEndSilenceMs);
  }

  // Frame processing (single-winner per frame; populates tileMetrics for debug)
  function processFrame(tsNow){
    if (!hasBoard || !detectionActive) return;
    const img = readBoardImageData(); if (!img) return;

    const inWarm = (tsNow - warmupStartTs) < config.warmupMs;
    if (debug.enabled){ tileMetrics.length = tileRects.length; }

    // winners for this frame
    let bestTealIdx = -1, bestTealScore = -1;
    let bestGreenIdx = -1, bestGreenScore = -1;

    for (let i=0;i<tileRects.length;i++){
      const t=tileRects[i], st=tileState[i];
      const cls = classifyTileRGBWithCounts(img,t);
      const avg=avgTileLuminance(img,t);
      st.baseline = st.baseline*(1-config.emaAlpha) + avg*config.emaAlpha;
      const delta = st.delta = avg - st.baseline;

      if (inWarm){
        st.belowLow = delta<=config.thrLow;
        st.hold=(delta>=config.thrHigh)?Math.min(config.holdFrames, st.hold+1):0;
        if (debug.enabled) tileMetrics[i] = {avg, base:st.baseline, delta, tealHits:cls.tealHits, greenHits:cls.greenHits, teal:cls.teal, green:cls.green};
        continue;
      }

      if (delta<=config.thrLow){ st.belowLow=true; st.lowCount=Math.min(255, st.lowCount+1); st.refractory=0; }
      else { st.belowLow=false; st.lowCount=0; if (st.refractory>0) st.refractory--; }

      st.hold=(delta>=config.thrHigh)?Math.min(config.holdFrames, st.hold+1):0;
      const byHold=(st.hold>=config.holdFrames), byEnergy=updateEnergy(tsNow,i,delta);
      const canRepeatBypass = st.lowCount >= config.belowLowFramesToBypass;
      const canTrigger = (st.refractory===0) || canRepeatBypass;

      if (canTrigger && (byHold||byEnergy)){
        if ((phase==='armed' || phase==='reveal') && cls.teal){
          const score = cls.tealHits*10 + Math.max(0, delta);
          if (score > bestTealScore){ bestTealScore=score; bestTealIdx=i; }
        }else if (phase==='waiting-input' && cls.green){
          const score = cls.greenHits*10 + Math.max(0, delta);
          if (score > bestGreenScore){ bestGreenScore=score; bestGreenIdx=i; }
        }
      }

      if (debug.enabled) tileMetrics[i] = {avg, base:st.baseline, delta, tealHits:cls.tealHits, greenHits:cls.greenHits, teal:cls.teal, green:cls.green};
    }

    // Build single-winner arrays and set refractory
    const tealIndices = [];
    const greenIndices = [];
    if (bestTealIdx >= 0){
      tealIndices.push(bestTealIdx);
      tileState[bestTealIdx].refractory = config.refractoryFrames;
    }
    if (bestGreenIdx >= 0){
      greenIndices.push(bestGreenIdx);
      tileState[bestGreenIdx].refractory = config.refractoryFrames;
    }

    // FSM
    switch(phase){
      case 'idle': break;

      case 'armed':
        if (!inWarm && config.requireColorToStartReveal && tealIndices.length>0){
          phase='reveal';
          revealSeq=[]; inputSeq=[];
          stepCluster=null; lastTealTs=tsNow;
          addToCluster(tsNow, tealIndices);
        }
        break;

      case 'reveal': {
        if (tealIndices.length>0) addToCluster(tsNow, tealIndices);
        maybeFinalizeCluster(tsNow);
        if (shouldEndReveal(tsNow)){
          phase='waiting-input';
          inputSeq=[]; inputStartTs=tsNow;
          revealLenExpected = revealSeq.length;
          guideHeader.style.display='block';
          guideHeader.textContent = `Step 1 / ${revealLenExpected}`;
        }
        break;
      }

      case 'waiting-input': {
        const expected = revealSeq[inputSeq.length] ?? -1;
        const inputElapsed = tsNow - inputStartTs;

        if (!inWarm && greenIndices.length>0){
          if (greenIndices.includes(expected)){
            const within = (tsNow - tileState[expected].lastHotTs) < config.dedupeMs;
            if (!within){
              inputSeq.push(expected);
              tileState[expected].lastHotTs = tsNow;
              elInputCount.textContent=String(inputSeq.length);
            }
          } else {
            badPressTile = greenIndices[0];
            badPressTs = tsNow;
          }
        }

        if (inputSeq.length >= revealLenExpected && revealLenExpected>0){
          roundIndex += 1;
          phase='rearming'; rearmTs=tsNow;
          revealSeq=[]; inputSeq=[]; revealLenExpected=0;
          guideHeader.style.display='none';
        }else if (inputElapsed >= config.inputTimeoutMs){
          phase='rearming'; rearmTs=tsNow; revealSeq=[]; inputSeq=[]; revealLenExpected=0; guideHeader.style.display='none';
        }
        break;
      }

      case 'rearming':
        if (tsNow - rearmTs >= config.rearmDelayMs){ phase='armed'; warmupStartTs=tsNow; }
        break;
    }
  }

  // Overlay drawing (includes debug overlays)
  function drawOverlay(){
    updateOverlayBox();

    const vw=overlay.width, vh=overlay.height;
    ctxOv.clearRect(0,0,vw,vh);
    const sx = vw/(video.videoWidth||1), sy = vh/(video.videoHeight||1);

    if (boardRect && video.videoWidth){
      // Board
      ctxOv.save();
      ctxOv.strokeStyle='rgba(88,176,255,0.95)'; ctxOv.setLineDash([6,4]); ctxOv.lineWidth=2;
      ctxOv.strokeRect(boardRect.x*sx, boardRect.y*sy, boardRect.w*sx, boardRect.h*sy);
      ctxOv.restore();

      // Tiles
      ctxOv.save();
      ctxOv.strokeStyle='rgba(140,200,255,0.28)'; ctxOv.lineWidth=1;
      for (const t of tileRects){ ctxOv.strokeRect(t.x*sx, t.y*sy, t.w*sx, t.h*sy); }
      ctxOv.restore();

      // Debug overlay: heatmap / samples / labels
      if (debug.enabled && tileMetrics.length===tileRects.length){
        if (debug.overlayHeatmap){
          for (let i=0;i<tileRects.length;i++){
            const t=tileRects[i], m=tileMetrics[i];
            const a = clamp(Math.abs(m.delta)/12, 0, 1);
            const pos = m.delta>=0;
            const r = pos ? Math.round(255*a) : 0;
            const g = pos ? Math.round(180*a) : Math.round(120*a);
            const b = pos ? 0 : Math.round(255*a);
            ctxOv.fillStyle = `rgba(${r},${g},${b},${0.28+0.22*a})`;
            ctxOv.fillRect(t.x*sx, t.y*sy, t.w*sx, t.h*sy);
          }
        }
        if (debug.overlaySamples){
          ctxOv.save();
          ctxOv.fillStyle='rgba(255,255,255,0.85)';
          for (let i=0;i<tileRects.length;i++){
            const t=tileRects[i];
            const offs=sampleOffsets[i];
            for (const p of offs){
              const px=(t.x+p[0])*sx, py=(t.y+p[1])*sy;
              ctxOv.fillRect(px-1, py-1, 2, 2);
            }
          }
          ctxOv.restore();
        }
        if (debug.overlayLabels){
          ctxOv.save();
          ctxOv.font='600 10px system-ui, -apple-system, Segoe UI, Roboto';
          ctxOv.textAlign='left'; ctxOv.textBaseline='top';
          for (let i=0;i<tileRects.length;i++){
            const t=tileRects[i], m=tileMetrics[i];
            const x=t.x*sx+3, y=t.y*sy+3;
            const lbl = `Δ:${m.delta.toFixed(1)}  L:${m.avg.toFixed(0)}  b:${m.base.toFixed(0)}  T:${m.tealHits} G:${m.greenHits}`;
            ctxOv.fillStyle='rgba(10,18,32,0.7)';
            ctxOv.fillRect(x-2,y-2, ctxOv.measureText(lbl).width+6, 14);
            ctxOv.fillStyle='#cfe6ff';
            ctxOv.fillText(lbl, x, y);
          }
          ctxOv.restore();
        }

        // Show cursor mask ring for tuning
        if (config.ignoreNearMouse && lastMouse.inBoard){
          // convert work px radius -> video px -> overlay px
          const rwVideo = config.cursorMaskRadiusPx * (boardRect.w/work.width);
          const rx = rwVideo * sx, ry = rwVideo * sy;
          ctxOv.save();
          ctxOv.strokeStyle = 'rgba(255,0,200,0.75)';
          ctxOv.setLineDash([6,4]);
          ctxOv.lineWidth = 2;
          ctxOv.beginPath();
          ctxOv.ellipse(lastMouse.xOverlay, lastMouse.yOverlay, rx, ry, 0, 0, Math.PI*2);
          ctxOv.stroke();
          ctxOv.restore();
        }
      }
    }

    // Step-by-step guide
    if (phase==='waiting-input' && revealSeq.length>0 && boardRect){
      const k = inputSeq.length; const N = revealLenExpected || revealSeq.length;
      guideHeader.style.display='block';
      guideHeader.textContent = `Step ${Math.min(k+1,N)} / ${N}`;

      const nextIdx = revealSeq[k] ?? null;
      const now = performance.now();
      const pulse = 0.5 + 0.5*Math.sin(now/180);
      if (nextIdx != null){
        const t = tileRects[nextIdx];
        if (t){
          const x=t.x*sx, y=t.y*sy, w=t.w*sx, h=t.h*sy;
          ctxOv.lineWidth = 3 + 2*pulse;
          ctxOv.strokeStyle = `rgba(34,197,94,${0.55 + 0.35*pulse})`;
          ctxOv.shadowColor = 'rgba(34,197,94,0.5)'; ctxOv.shadowBlur = 12*pulse;
          ctxOv.strokeRect(x,y,w,h);
        }
      }
      // wrong press flash
      if (badPressTile>=0 && (now - badPressTs) < 300){
        const t = tileRects[badPressTile];
        if (t){
          const x=t.x*sx, y=t.y*sy, w=t.w*sx, h=t.h*sy;
          ctxOv.lineWidth = 4;
          ctxOv.strokeStyle = 'rgba(239,68,68,0.9)';
          ctxOv.shadowColor = 'rgba(239,68,68,0.6)'; ctxOv.shadowBlur = 10;
          ctxOv.strokeRect(x,y,w,h);
        }
      }
    } else {
      guideHeader.style.display='none';
    }

    // Editor visuals
    if (editor.mode==='draw' && editor.rect){
      const r=editor.rect, sq=squareFromRectCentered(r,vw,vh);
      ctxOv.save();
      ctxOv.setLineDash([8,6]); ctxOv.lineWidth=2; ctxOv.strokeStyle='rgba(88,176,255,0.95)';
      ctxOv.fillStyle='rgba(88,176,255,0.14)'; ctxOv.fillRect(sq.x,sq.y,sq.w,sq.h); ctxOv.strokeRect(sq.x,sq.y,sq.w,sq.h);
      ctxOv.restore();
    }
    if (editor.mode==='edit' && editor.rect){
      const r=editor.rect;
      ctxOv.save();
      ctxOv.setLineDash([8,6]); ctxOv.lineWidth=2; ctxOv.strokeStyle='rgba(88,176,255,0.95)';
      ctxOv.fillStyle='rgba(88,176,255,0.10)'; ctxOv.fillRect(r.x,r.y,r.w,r.h); ctxOv.strokeRect(r.x,r.y,r.w,r.h);
      ctxOv.restore();
      const hs=editor.handleSize;
      for (const h of getHandleRects(r,hs)){
        ctxOv.fillStyle='rgba(88,176,255,0.95)'; ctxOv.fillRect(h.x,h.y,h.w,h.h);
        ctxOv.strokeStyle='#0b1220'; ctxOv.lineWidth=1.5; ctxOv.strokeRect(h.x,h.y,h.w,h.h);
      }
    }
  }

  // Debug viewer (tile-level render)
  function drawDebugViewer(){
    if (!debug.enabled || !hasBoard || tileMetrics.length!==tileRects.length) {
      ctxDbg.fillStyle='#0b1220'; ctxDbg.fillRect(0,0,debugView.width,debugView.height);
      if (hasBoard && work.width>0 && debug.view==='raw') {
        ctxDbg.drawImage(work, 0,0, debugView.width, debugView.height);
      }
      return;
    }
    ctxDbg.fillStyle='#0b1220'; ctxDbg.fillRect(0,0,debugView.width,debugView.height);

    if (debug.view==='raw'){
      ctxDbg.drawImage(work, 0,0,debugView.width,debugView.height);
    } else {
      ctxDbg.globalAlpha=0.25;
      if (work.width>0) ctxDbg.drawImage(work, 0,0,debugView.width,debugView.height);
      ctxDbg.globalAlpha=1;
    }

    const sx = (boardRect ? debugView.width/boardRect.w : 1);
    const sy = (boardRect ? debugView.height/boardRect.h : 1);

    for (let i=0;i<tileRects.length;i++){
      const t=tileRects[i], m=tileMetrics[i];
      const x=(t.x-boardRect.x)*sx, y=(t.y-boardRect.y)*sy, w=t.w*sx, h=t.h*sy;

      if (debug.view==='grayscale'){
        const L = clamp(Math.round(m.avg), 0, 255);
        ctxDbg.fillStyle = `rgb(${L},${L},${L})`;
        ctxDbg.fillRect(x,y,w,h);
      } else if (debug.view==='delta'){
        const a = clamp(Math.abs(m.delta)/12, 0, 1);
        const pos = m.delta>=0;
        const r = pos ? Math.round(255*a) : 0;
        const g = pos ? Math.round(180*a) : Math.round(120*a);
        const b = pos ? 0 : Math.round(255*a);
        ctxDbg.fillStyle = `rgba(${r},${g},${b},${0.55})`;
        ctxDbg.fillRect(x,y,w,h);
      } else if (debug.view==='teal'){
        const ratio = clamp(m.tealHits/25, 0, 1);
        ctxDbg.fillStyle = `rgba(45,212,212,${0.15 + 0.6*ratio})`;
        ctxDbg.fillRect(x,y,w,h);
      } else if (debug.view==='green'){
        const ratio = clamp(m.greenHits/25, 0, 1);
        ctxDbg.fillStyle = `rgba(34,197,94,${0.15 + 0.6*ratio})`;
        ctxDbg.fillRect(x,y,w,h);
      }

      ctxDbg.strokeStyle = 'rgba(140,200,255,0.35)';
      ctxDbg.lineWidth = 1;
      ctxDbg.strokeRect(x,y,w,h);

      if (debug.overlayLabels){
        ctxDbg.font='600 10px system-ui, -apple-system, Segoe UI, Roboto';
        ctxDbg.fillStyle='#cfe6ff'; ctxDbg.textAlign='left'; ctxDbg.textBaseline='top';
        const lbl = `Δ:${m.delta.toFixed(1)} L:${m.avg.toFixed(0)} b:${m.base.toFixed(0)} T:${m.tealHits} G:${m.greenHits}`;
        ctxDbg.fillText(lbl, x+3, y+2);
      }
    }
  }

  // Editor helpers
  function getHandleRects(r,hs){
    return [
      {name:'nw', x:r.x-hs/2, y:r.y-hs/2, w:hs, h:hs},
      {name:'ne', x:r.x+r.w-hs/2, y:r.y-hs/2, w:hs, h:hs},
      {name:'se', x:r.x+r.w-hs/2, y:r.y+r.h-hs/2, w:hs, h:hs},
      {name:'sw', x:r.x-hs/2, y:r.y+r.h-hs/2, w:hs, h:hs},
    ];
  }
  function hitTestHandle(x,y,r,hs){ for (const h of getHandleRects(r,hs)){ if (x>=h.x&&x<=h.x+h.w&&y>=h.y&&y<=h.y+h.h) return h.name; } return null; }
  function pointInRect(x,y,r){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }
  function clampRect(x0,y0,dx,dy,maxW,maxH){
    const x1=clamp(x0+dx,0,maxW), y1=clamp(y0+dy,0,maxH);
    const x=clamp(Math.min(x0,x1),0,maxW), y=clamp(Math.min(y0,y1),0,maxH);
    const w=clamp(Math.abs(x1-x0),0,maxW-x), h=clamp(Math.abs(y1-y0),0,maxH-y);
    return {x,y,w,h};
  }
  function squareFromRectCentered(r,maxW,maxH){
    const cx=r.x+r.w/2, cy=r.y+r.h/2, side=Math.min(Math.max(r.w,r.h), Math.min(maxW,maxH));
    let x=cx-side/2, y=cy-side/2; x=clamp(x,0,maxW-side); y=clamp(y,0,maxH-side);
    return {x,y,w:side,h:side};
  }
  function squareResizeFromCorner(startRect, handle, dx, dy, maxW, maxH){
    const minSide=20; let side=startRect.w, x=startRect.x, y=startRect.y;
    if (handle==='se'){ const desired=side+Math.max(dx,dy); const maxSide=Math.min(maxW-startRect.x, maxH-startRect.y); side=clamp(desired,minSide,maxSide); }
    else if (handle==='ne'){ const desired=side+Math.max(dx,-dy); const maxSide=Math.min(maxW-startRect.x, startRect.y+startRect.h); side=clamp(desired,minSide,maxSide); y=(startRect.y+startRect.h)-side; y=clamp(y,0,maxH-side); }
    else if (handle==='nw'){ const desired=side+Math.max(-dx,-dy); const maxSide=Math.min(startRect.x+startRect.w, startRect.y+startRect.h); side=clamp(desired,minSide,maxSide); x=(startRect.x+startRect.w)-side; y=(startRect.y+startRect.h)-side; x=clamp(x,0,maxW-side); y=clamp(y,0,maxH-side); }
    else if (handle==='sw'){ const desired=side+Math.max(-dx,dy); const maxSide=Math.min(startRect.x+startRect.w, maxH-startRect.y); side=clamp(desired,minSide,maxSide); x=(startRect.x+startRect.w)-side; x=clamp(x,0,maxW-side); }
    return {x,y,w:side,h:side};
  }
  function squareMove(startRect,dx,dy,maxW,maxH){
    const x=clamp(startRect.x+dx,0,maxW-startRect.w), y=clamp(startRect.y+dy,0,maxH-startRect.h);
    return {x,y,w:startRect.w,h:startRect.h};
  }

  function commitEditorRectToBoard(){
    if (!editor.rect || !video.videoWidth) return;
    const vw=overlay.width, vh=overlay.height, sx=(video.videoWidth||1)/vw, sy=(video.videoHeight||1)/vh;
    const r=editor.rect;
    boardRect={ x:r.x*sx, y:r.y*sy, w:r.w*sx, h:r.h*sy };
    tileRects = buildTilesFromSquare(boardRect.x,boardRect.y,boardRect.w,boardRect.h);
    hasBoard=true; ensureTileState(); calibrateBaselines();
    btnEditBoard.disabled=false; btnClearBoard.disabled=false;
  }

  // Calibration
  function calibrateBaselines(){
    if (!hasBoard) return;
    const data = readBoardImageData(); if (!data) return;
    for (let i=0;i<tileRects.length;i++){
      const t=tileRects[i]; const avg=avgTileLuminance(data,t);
      const st=tileState[i]; st.baseline=avg; st.delta=0; st.energyBuf.fill(0); st.energySum=0; st.eIdx=0;
      st.hold=0; st.refractory=0; st.lowCount=0; st.belowLow=true; st.lastHotTs=0;
    }
    warmupStartTs = performance.now();
  }

  // Loops
  function uiLoop(){ if (!running) return; drawOverlay(); if (debug.enabled) drawDebugViewer(); requestAnimationFrame(uiLoop); }
  function videoLoopRaf(){
    if (!running) return;
    const tsNow=performance.now();
    framesInBucket++; if (tsNow-lastFPSTs>=1000){ elFPS.textContent=String(framesInBucket); framesInBucket=0; lastFPSTs=tsNow; }
    if (detectionActive){ processFrame(tsNow); updateStatus(); }
    requestAnimationFrame(videoLoopRaf);
  }
  function videoLoopVFC(now){
    if (!running) return;
    framesInBucket++; if (now-lastFPSTs>=1000){ elFPS.textContent=String(framesInBucket); framesInBucket=0; lastFPSTs=now; }
    if (detectionActive){ processFrame(now); updateStatus(); }
    video.requestVideoFrameCallback(videoLoopVFC);
  }
  function startLoops(){
    lastFPSTs=performance.now(); framesInBucket=0;
    requestAnimationFrame(uiLoop);
    if (typeof video.requestVideoFrameCallback==='function'){ video.requestVideoFrameCallback(videoLoopVFC); }
    else { requestAnimationFrame(videoLoopRaf); }
  }

  // Capture
  async function startCapture(){
    try{
      stream = await navigator.mediaDevices.getDisplayMedia({
        video:{ displaySurface:'window', frameRate:{ideal:60,max:60}, cursor:'never' }, audio:false
      });
      video.srcObject = stream;
      track = stream.getVideoTracks()[0];
      try{ await track.applyConstraints({ frameRate:{ideal:60,max:60} }); }catch(_){}
      try{ if ('contentHint' in track) track.contentHint='motion'; }catch(_){}
      btnCapture.disabled=true; btnStopCapture.disabled=false;
      running=true; startLoops();
    }catch(e){ console.error(e); alert('Screen/window capture was not granted.'); }
  }
  function stopCapture(){
    if (stream){ stream.getTracks().forEach(t=>t.stop()); }
    stream=null; track=null; video.srcObject=null; running=false;
    btnCapture.disabled=false; btnStopCapture.disabled=true;
  }

  // Events
  btnCapture.addEventListener('click', startCapture);
  btnStopCapture.addEventListener('click', ()=>{ stopCapture(); resetDetectionState({clearBoard:true}); drawOverlay(); });

  btnSetBoard.addEventListener('click', ()=>{
    if (!video.videoWidth){ alert('Start capture first.'); return; }
    updateOverlayBox();
    editor.mode='draw';
    editor.rect=null;
    setOverlayPointer(true);
    btnDoneEdit.disabled=true;
    drawOverlay();
  });
  btnEditBoard.addEventListener('click', ()=>{
    if (!boardRect){ alert('Set the board first.'); return; }
    updateOverlayBox();
    const vw=overlay.width, vh=overlay.height, sx=vw/(video.videoWidth||1), sy=vh/(video.videoHeight||1);
    editor.rect={ x:boardRect.x*sx, y:boardRect.y*sy, w:boardRect.w*sx, h:boardRect.h*sy };
    editor.mode='edit';
    setOverlayPointer(true);
    btnDoneEdit.disabled=false;
    drawOverlay();
  });
  btnDoneEdit.addEventListener('click', ()=>{
    if (editor.mode==='edit'){
      commitEditorRectToBoard();
      editor.mode='idle';
      setOverlayPointer(false);
      btnDoneEdit.disabled=true;
      drawOverlay();
    }
  });
  btnClearBoard.addEventListener('click', ()=>{ resetDetectionState({clearBoard:true}); drawOverlay(); });

  btnCalibrate.addEventListener('click', ()=>{ if (!hasBoard){ alert('Set the board first.'); return; } calibrateBaselines(); updateStatus(); });

  btnStart.addEventListener('click', ()=>{
    if (!stream){ alert('Start capture first.'); return; }
    if (!hasBoard){ alert('Set the board first.'); return; }
    detectionActive=true; phase='armed'; warmupStartTs=performance.now();
    btnStart.disabled=true; btnStop.disabled=false; updateStatus();
  });
  btnStop.addEventListener('click', ()=>{ detectionActive=false; phase='idle'; btnStart.disabled=false; btnStop.disabled=true; updateStatus(); });

  btnResetRounds.addEventListener('click', ()=>{ resetRounds(); });

  selDifficulty.addEventListener('change', ()=>{ difficulty=selDifficulty.value; updateGridFromDifficulty(); resetDetectionState({clearBoard:true}); drawOverlay(); });
  btnTimingDefaults.addEventListener('click', ()=>{ Object.assign(config, defaultConfig); buildTimingPanel(); });

  ckDebug.addEventListener('change', ()=>{ debug.enabled = ckDebug.checked; drawOverlay(); drawDebugViewer(); });
  ckDbgHeat.addEventListener('change', ()=>{ debug.overlayHeatmap = ckDbgHeat.checked; });
  ckDbgSamples.addEventListener('change', ()=>{ debug.overlaySamples = ckDbgSamples.checked; });
  ckDbgLabels.addEventListener('change', ()=>{ debug.overlayLabels = ckDbgLabels.checked; });
  ckIgnoreCursor.addEventListener('change', ()=>{ config.ignoreCursor = ckIgnoreCursor.checked; });
  ckIgnoreNearMouse.addEventListener('change', ()=>{ config.ignoreNearMouse = ckIgnoreNearMouse.checked; });
  inpCursorRadius.addEventListener('change', ()=>{ const v=Number(inpCursorRadius.value); if (Number.isFinite(v)) config.cursorMaskRadiusPx = Math.max(4, Math.min(40, Math.round(v))); });
  selDbgView.addEventListener('change', ()=>{ debug.view = selDbgView.value; });

  // Ensure UI reflects defaults
  ckIgnoreCursor.checked = config.ignoreCursor;
  ckIgnoreNearMouse.checked = config.ignoreNearMouse;
  inpCursorRadius.value = String(config.cursorMaskRadiusPx);

  // Timing panel
  function buildTimingPanel(){
    timingGrid.innerHTML='';
    const fields = [
      {key:'revealStepGapMs', label:'Step Gap (ms)', step:10, min:80, max:400},
      {key:'revealEndSilenceMs', label:'Reveal End Silence (ms)', step:25, min:300, max:2000},
      {key:'minStepSplitMs', label:'Min Split (ms)', step:5, min:40, max:200},
      {key:'dedupeMs', label:'Pulse Dedupe (ms)', step:10, min:60, max:600},
      {key:'belowLowFramesToBypass', label:'Below-Low Frames to Repeat', step:1, min:0, max:12},
      {key:'holdFrames', label:'Hold Frames', step:1, min:0, max:8},
      {key:'refractoryFrames', label:'Refractory Frames', step:1, min:0, max:20},
      {key:'inputTimeoutMs', label:'Input Timeout (ms)', step:250, min:3000, max:30000},
      {key:'rearmDelayMs', label:'Rearm Delay (ms)', step:10, min:30, max:500},
    ];
    for (const f of fields){
      const wrap=document.createElement('div');
      const lab=document.createElement('label'); lab.textContent=f.label; lab.htmlFor=`tim_${f.key}`;
      const inp=document.createElement('input');
      inp.type='number'; inp.id=`tim_${f.key}`; inp.value=String(config[f.key]);
      if (f.step!=null) inp.step=String(f.step);
      if (f.min!=null) inp.min=String(f.min);
      if (f.max!=null) inp.max=String(f.max);
      inp.addEventListener('change', ()=>{
        const v=Number(inp.value); if (!Number.isFinite(v)) return;
        config[f.key] = (['holdFrames','refractoryFrames','belowLowFramesToBypass'].includes(f.key)) ? Math.round(v) : v;
      });
      wrap.appendChild(lab); wrap.appendChild(inp);
      timingGrid.appendChild(wrap);
    }
  }

  // Link overlay sizing
  window.addEventListener('resize', updateOverlayBox);
  video.addEventListener('loadedmetadata', updateOverlayBox);
  video.addEventListener('play', updateOverlayBox);

  // Init
  updateGridFromDifficulty();
  buildTimingPanel();
  resetDetectionState({clearBoard:true});

  const ro = new ResizeObserver(()=> updateOverlayBox());
  ro.observe(previewWrap);

})();
</script>
</body>
</html>