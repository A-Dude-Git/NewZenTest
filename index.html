<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Zen Solver</title>
<style>
  :root{
    --navy-900:#0b1220; --navy-850:#0f1a2b; --navy-800:#122036; --navy-750:#152744;
    --blue-500:#3aa0ff; --blue-400:#58b0ff; --blue-300:#8cc8ff;
    --green-400:#38d677; --green-500:#22c55e; --red-400:#ef4444;
    --text-100:#e6eef7; --text-200:#c3d4ea; --muted-400:#7f9bb9;
    --card-radius:12px; --shadow:0 6px 18px rgba(0,0,0,.35); --mono:ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 800px at 20% 0%, var(--navy-800), var(--navy-900));
    color:var(--text-100); font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; line-height:1.4;
  }
  .app{display:grid; grid-template-columns:420px 1fr; gap:16px; padding:16px; height:100dvh}
  .card{
    background:linear-gradient(180deg, var(--navy-800), var(--navy-850));
    border:1px solid rgba(90,140,200,.15); border-radius:var(--card-radius); box-shadow:var(--shadow);
    overflow:hidden; display:flex; flex-direction:column;
  }
  .card-header{padding:12px 14px; border-bottom:1px solid rgba(120,170,230,.15); font-weight:600; color:var(--blue-300); display:flex; align-items:center; justify-content:space-between}
  .card-body{padding:14px; overflow:auto}
  .controls{display:grid; gap:12px}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  button,select{
    background:linear-gradient(180deg, var(--navy-750), var(--navy-800));
    border:1px solid rgba(80,130,200,.25); color:var(--text-100); border-radius:10px; padding:10px 12px; font-size:14px; cursor:pointer; transition:all .15s ease;
  }
  button:hover,select:hover{border-color:var(--blue-400); box-shadow:0 0 0 3px rgba(60,160,255,.15) inset}
  button.primary{background:linear-gradient(180deg,#0d2b4a,#0e2141); border-color:rgba(58,160,255,.7); color:var(--blue-300); font-weight:600}
  button.success{border-color:rgba(56,214,119,.6); color:var(--green-400)}
  button.warn{border-color:rgba(255,107,107,.5); color:#ff9b9b}
  button.ghost{border-color:rgba(120,170,230,.35); color:var(--text-200)}
  button:disabled{opacity:.55; cursor:not-allowed}
  label{display:block; margin-bottom:6px; color:var(--text-200)}
  input[type="number"]{
    width:100%; padding:8px 10px; border-radius:8px;
    background:linear-gradient(180deg, var(--navy-750), var(--navy-800));
    border:1px solid rgba(80,130,200,.25); color:var(--text-100);
    font-variant-numeric: tabular-nums; font-family: var(--mono);
  }
  .status{display:grid; grid-template-columns:repeat(3, 1fr); gap:8px; margin-top:8px; font-family:var(--mono); font-variant-numeric:tabular-nums}
  .status div{padding:8px; background:linear-gradient(180deg, var(--navy-800), var(--navy-850)); border:1px solid rgba(90,140,200,.2); border-radius:8px; color:var(--text-200)}
  .status strong{color:var(--text-100)}
  .preview-wrap{position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:radial-gradient(800px 600px at 50% 0%, #0e1a2e, #0b1220)}
  video{max-width:100%; max-height:100%; border-radius:10px; border:1px solid rgba(80,130,200,.25); background:#000}
  canvas.overlay{position:absolute}
  .overlay.pe-none{pointer-events:none}
  .overlay.pe-auto{pointer-events:auto}
  .grid{display:grid; gap:10px}
  .grid.cols-2{grid-template-columns:1fr 1fr}
  .divider{height:1px; background:linear-gradient(90deg, transparent, rgba(130,160,210,.25), transparent); margin:8px 0}
  .badge{display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; border:1px solid rgba(90,140,200,.25); color:var(--text-200); font-size:12px; background:linear-gradient(180deg, var(--navy-800), var(--navy-850))}
  .badge .dot{width:8px; height:8px; border-radius:50%; background:var(--blue-500)}
  .legend{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; color:var(--muted-400); font-size:12px}
  .legend span{display:inline-flex; align-items:center; gap:6px}
  .legend .teal{width:10px; height:10px; background:#2dd4d4; border-radius:2px}
  .legend .green{width:10px; height:10px; background:#22c55e; border-radius:2px}
  .legend .board{width:10px; height:10px; background:transparent; border:1px dashed #58b0ff; border-radius:2px}
  .guideHeader{
    position:absolute; left:12px; top:12px; padding:6px 10px; border-radius:10px;
    background:rgba(10,18,32,0.55); border:1px solid rgba(140,200,255,0.35); backdrop-filter: blur(4px);
    font-weight:600; color:#cfe6ff; z-index:2; pointer-events:none;
  }
  @media (max-width:1100px){.app{grid-template-columns:1fr; height:auto}.card-body{max-height:55vh}.preview-wrap{height:55vh}}
</style>
</head>
<body>
  <div class="app">
    <!-- Left: Controls -->
    <section class="card">
      <div class="card-header">
        <div>Controls</div>
        <div class="badge"><span class="dot"></span> Zen Solver</div>
      </div>
      <div class="card-body">
        <div class="controls">
          <div class="row">
            <button id="btnCapture" class="primary">Start Capture</button>
            <button id="btnStopCapture" class="warn" disabled>Stop Capture</button>
          </div>

          <div class="row">
            <button id="btnSetBoard" class="ghost">Set Board</button>
            <button id="btnEditBoard" class="ghost" disabled>Edit Board</button>
            <button id="btnDoneEdit" class="success" disabled>Done</button>
            <button id="btnClearBoard" class="ghost" disabled>Clear</button>
          </div>

          <div class="row">
            <button id="btnCalibrate" class="">Calibrate</button>
            <button id="btnStart" class="success">Start Detection</button>
            <button id="btnStop" class="warn" disabled>Stop Detection</button>
            <button id="btnResetRounds" class="">Reset Rounds</button>
          </div>

          <div class="divider"></div>

          <div>
            <label for="difficulty">Difficulty</label>
            <select id="difficulty">
              <option value="easy">Easy (4×4)</option>
              <option value="medium">Medium (5×5)</option>
              <option value="hard">Hard (6×6)</option>
              <option value="expert" selected>Expert (6×6)</option>
            </select>
            <div class="legend" style="margin-top:6px">
              <span><i class="board"></i> Board</span>
              <span><i class="teal"></i> Teal (Reveal)</span>
              <span><i class="green"></i> Green (Input)</span>
              <span>Guide shows only the next tile to press (instant advance)</span>
            </div>
          </div>

          <div class="divider"></div>

          <div>
            <div style="display:flex;align-items:center;justify-content:space-between">
              <label>Timing</label>
              <button id="btnTimingDefaults" title="Restore Timing Defaults">Restore Timing Defaults</button>
            </div>
            <div class="grid cols-2" id="timingGrid"></div>
          </div>

          <div class="divider"></div>

          <div class="status" id="status">
            <div>FPS: <strong id="fps">0</strong></div>
            <div>Phase: <strong id="phase">idle</strong></div>
            <div>Round: <strong id="round">1</strong></div>
            <div>Reveal: <strong id="revealCount">0</strong></div>
            <div>Input: <strong id="inputCount">0</strong></div>
            <div>Grid: <strong id="gridSize">6×6</strong></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Center: Video + Overlay -->
    <section class="card">
      <div class="card-header">Preview</div>
      <div class="preview-wrap" id="previewWrap">
        <div id="guideHeader" class="guideHeader" style="display:none">Step 1 / 1</div>
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay" class="overlay pe-none"></canvas>
      </div>
    </section>
  </div>

<script>
(function(){
  // DOM
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const previewWrap = document.getElementById('previewWrap');
  const guideHeader = document.getElementById('guideHeader');
  const ctxOv = overlay.getContext('2d', { alpha: true });

  const btnCapture = document.getElementById('btnCapture');
  const btnStopCapture = document.getElementById('btnStopCapture');
  const btnSetBoard = document.getElementById('btnSetBoard');
  const btnEditBoard = document.getElementById('btnEditBoard');
  const btnDoneEdit = document.getElementById('btnDoneEdit');
  const btnClearBoard = document.getElementById('btnClearBoard');
  const btnCalibrate = document.getElementById('btnCalibrate');
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnResetRounds = document.getElementById('btnResetRounds');

  const selDifficulty = document.getElementById('difficulty');
  const btnTimingDefaults = document.getElementById('btnTimingDefaults');
  const timingGrid = document.getElementById('timingGrid');

  const elFPS = document.getElementById('fps');
  const elPhase = document.getElementById('phase');
  const elRound = document.getElementById('round');
  const elRevealCount = document.getElementById('revealCount');
  const elInputCount = document.getElementById('inputCount');
  const elGridSize = document.getElementById('gridSize');

  // Speed-focused defaults
  const defaultConfig = {
    // detection baseline
    thrHigh:9, thrLow:5, holdFrames:0, refractoryFrames:3, emaAlpha:0.25,
    energyWindow:4, energyScale:2.2, warmupMs:350, surgeRejectPct:0.45,
    // input window
    inputTimeoutMs:8000,
    // cluster timing (fast)
    revealStepGapMs:150,
    revealEndSilenceMs:300,
    // de-dupe and repeats
    dedupeMs:90,
    belowLowFramesToBypass:0,
    // rearm
    rearmDelayMs:100,
    // behavior
    requireColorToStartReveal:true
  };
  const config = { ...defaultConfig };

  // Defaults
  let difficulty='expert', rows=6, cols=6;

  // State
  let stream=null, track=null, running=false, detectionActive=false, hasBoard=false;

  let boardRect=null; // in video coords
  let tileRects=[];

  const work = document.createElement('canvas');
  const wctx = work.getContext('2d', { willReadFrequently:true });

  let tileState=[], sampleOffsets=[];

  // FSM
  let phase='idle'; // 'idle'|'armed'|'reveal'|'waiting-input'|'rearming'
  let roundIndex=0;
  let revealSeq=[];       // captured steps
  let inputSeq=[];        // accepted inputs (strict order)
  let revealLenExpected=0;

  // Timing marks
  let warmupStartTs=0, inputStartTs=0, rearmTs=0;

  // Reveal clusterer
  let stepCluster=null;   // { startTs, tally: Map }
  let lastTealTs=0;

  // FPS
  let lastFPSTs=0, framesInBucket=0;

  // Wrong press flash
  let badPressTs=0, badPressTile=-1;

  // Editor
  const editor = { mode:'idle', rect:null, activeHandle:null, start:{x:0,y:0}, rectStart:null, handleSize:12 };

  // Utils
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function luminance(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }
  function rgbToHsv(r,g,b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    const d=max-min;
    let h=0;
    if (d!==0){
      if (max===r) h=((g-b)/d)%6;
      else if (max===g) h=(b-r)/d+2;
      else h=(r-g)/d+4;
      h*=60; if (h<0) h+=360;
    }
    const s=max===0?0:d/max;
    const v=max;
    return [h,s,v];
  }

  // Color classifiers (RGB + HSV fallback)
  function isTealRGB(r,g,b){ return g>=90 && b>=90 && g>=1.22*r && b>=1.12*r && g<=1.65*b; }
  function isGreenRGB(r,g,b){ return g>=105 && g>=1.38*r && g>=1.2*b; }
  function isTealHSV(h,s,v){ return s>=0.25 && v>=0.28 && h>=160 && h<=205; }
  function isGreenHSV(h,s,v){ return s>=0.30 && v>=0.32 && h>=80 && h<=150; }

  // Overlay sizing
  function updateOverlayBox(){
    const v = video.getBoundingClientRect();
    const p = previewWrap.getBoundingClientRect();
    overlay.style.left = (v.left - p.left)+'px';
    overlay.style.top  = (v.top  - p.top )+'px';
    overlay.style.width = v.width+'px';
    overlay.style.height = v.height+'px';
    const w = Math.max(1, Math.round(v.width));
    const h = Math.max(1, Math.round(v.height));
    if (overlay.width !== w) overlay.width = w;
    if (overlay.height !== h) overlay.height = h;
  }

  // Tiles
  function buildTilesFromSquare(bx,by,bw,bh){
    const stepX=bw/cols, stepY=bh/rows;
    const gap=0.12;
    const wTile=stepX*(1-gap), hTile=stepY*(1-gap);
    const gx=stepX-wTile, gy=stepY-hTile;
    const out=[]; let idx=0;
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const x=bx + c*stepX + gx*0.5;
        const y=by + r*stepY + gy*0.5;
        out.push({ x,y,w:wTile,h:hTile,row:r,col:c,index:idx++ });
      }
    }
    return out;
  }

  // UI status
  function updateGridFromDifficulty(){
    switch(difficulty){
      case 'easy': rows=4; cols=4; break;
      case 'medium': rows=5; cols=5; break;
      case 'hard': case 'expert': rows=6; cols=6; break;
      default: rows=6; cols=6;
    }
    elGridSize.textContent = `${cols}×${rows}`;
  }
  function updateStatus(){
    elPhase.textContent=phase;
    elRound.textContent=String(roundIndex+1);
    elRevealCount.textContent=String(revealSeq.length);
    elInputCount.textContent=String(inputSeq.length);
  }
  function resetDetectionState({clearBoard=true}={}){
    detectionActive=false; btnStart.disabled=false; btnStop.disabled=true;
    phase='idle'; roundIndex=0; revealSeq=[]; inputSeq=[]; revealLenExpected=0;
    warmupStartTs=performance.now();
    stepCluster=null; lastTealTs=0; badPressTs=0; badPressTile=-1;
    guideHeader.style.display='none'; guideHeader.textContent='';
    if (clearBoard){
      boardRect=null; tileRects=[]; tileState=[]; sampleOffsets=[]; hasBoard=false;
      btnEditBoard.disabled=true; btnDoneEdit.disabled=true; btnClearBoard.disabled=true;
      Object.assign(editor,{mode:'idle',rect:null,activeHandle:null});
    }
    updateStatus();
  }
  function resetRounds(){
    roundIndex=0; revealSeq=[]; inputSeq=[]; revealLenExpected=0;
    phase='armed'; warmupStartTs=performance.now(); stepCluster=null; lastTealTs=0;
    guideHeader.style.display='none'; guideHeader.textContent='';
    updateStatus();
  }

  // Timing panel
  function buildTimingPanel(){
    timingGrid.innerHTML='';
    const fields = [
      {key:'revealStepGapMs', label:'Step Gap (ms)', step:10, min:80, max:400},
      {key:'revealEndSilenceMs', label:'Reveal End Silence (ms)', step:10, min:150, max:1500},
      {key:'dedupeMs', label:'Pulse Dedupe (ms)', step:10, min:60, max:300},
      {key:'belowLowFramesToBypass', label:'Below-Low Frames to Repeat', step:1, min:0, max:8},
      {key:'holdFrames', label:'Hold Frames', step:1, min:0, max:6},
      {key:'refractoryFrames', label:'Refractory Frames', step:1, min:0, max:12},
      {key:'inputTimeoutMs', label:'Input Timeout (ms)', step:250, min:3000, max:20000},
      {key:'rearmDelayMs', label:'Rearm Delay (ms)', step:10, min:50, max:500},
    ];
    for (const f of fields){
      const wrap=document.createElement('div');
      const lab=document.createElement('label'); lab.textContent=f.label; lab.htmlFor=`tim_${f.key}`;
      const inp=document.createElement('input');
      inp.type='number'; inp.id=`tim_${f.key}`; inp.value=String(config[f.key]);
      if (f.step!=null) inp.step=String(f.step);
      if (f.min!=null) inp.min=String(f.min);
      if (f.max!=null) inp.max=String(f.max);
      inp.addEventListener('change', ()=>{
        const v=Number(inp.value); if (!Number.isFinite(v)) return;
        config[f.key] = (['holdFrames','refractoryFrames','belowLowFramesToBypass'].includes(f.key)) ? Math.round(v) : v;
      });
      wrap.appendChild(lab); wrap.appendChild(inp);
      timingGrid.appendChild(wrap);
    }
  }
  btnTimingDefaults.addEventListener('click', ()=>{ Object.assign(config, defaultConfig); buildTimingPanel(); });

  // Capture
  async function startCapture(){
    try{
      stream = await navigator.mediaDevices.getDisplayMedia({
        video:{ displaySurface:'window', frameRate:{ideal:60,max:60}, cursor:'never' }, audio:false
      });
      video.srcObject = stream;
      track = stream.getVideoTracks()[0];
      try{ await track.applyConstraints({ frameRate:{ideal:60,max:60} }); }catch(_){}
      try{ if ('contentHint' in track) track.contentHint='motion'; }catch(_){}
      btnCapture.disabled=true; btnStopCapture.disabled=false;
      running=true; startLoops();
    }catch(e){ console.error(e); alert('Screen/window capture was not granted.'); }
  }
  function stopCapture(){
    if (stream){ stream.getTracks().forEach(t=>t.stop()); }
    stream=null; track=null; video.srcObject=null; running=false;
    btnCapture.disabled=false; btnStopCapture.disabled=true;
  }

  // Sampling and classification
  function ensureTileState(){
    tileState = tileRects.map(()=>({
      baseline:0, delta:0,
      energyBuf:new Float32Array(config.energyWindow), energySum:0, eIdx:0,
      hold:0, refractory:0, lowCount:0, belowLow:true,
      lastHotTs:0
    }));
    sampleOffsets = tileRects.map((t)=>{
      const pts=[], insetX=t.w*0.15, insetY=t.h*0.15, wSpan=t.w*0.70, hSpan=t.h*0.70;
      for (let yi=0; yi<5; yi++){ for (let xi=0; xi<5; xi++){ pts.push([insetX+wSpan*(xi/4), insetY+hSpan*(yi/4)]); } }
      return pts;
    });
  }
  function readBoardImageData(){
    if (!boardRect || !video.videoWidth) return null;
    work.width=Math.max(2,Math.floor(boardRect.w)); work.height=Math.max(2,Math.floor(boardRect.h));
    wctx.drawImage(video, boardRect.x,boardRect.y,boardRect.w,boardRect.h, 0,0, work.width,work.height);
    return wctx.getImageData(0,0,work.width,work.height);
  }
  function avgTileLuminance(img,t){
    const sx=work.width/boardRect.w, sy=work.height/boardRect.h, off=sampleOffsets[t.index];
    let sum=0;
    for (let i=0;i<off.length;i++){
      const ox=off[i][0]*sx + (t.x-boardRect.x)*sx, oy=off[i][1]*sy + (t.y-boardRect.y)*sy;
      const xi=Math.max(0,Math.min(work.width-1,ox|0)), yi=Math.max(0,Math.min(work.height-1,oy|0));
      const idx=(yi*work.width+xi)*4; sum += luminance(img.data[idx], img.data[idx+1], img.data[idx+2]);
    }
    return sum/off.length;
  }
  function classifyTile(img,t){
    const sx=work.width/boardRect.w, sy=work.height/boardRect.h, off=sampleOffsets[t.index];
    let tealHits=0, greenHits=0;
    for (let i=0;i<off.length;i++){
      const ox=off[i][0]*sx + (t.x-boardRect.x)*sx, oy=off[i][1]*sy + (t.y-boardRect.y)*sy;
      const xi=Math.max(0,Math.min(work.width-1,ox|0)), yi=Math.max(0,Math.min(work.height-1,oy|0));
      const idx=(yi*work.width+xi)*4, r=img.data[idx], g=img.data[idx+1], b=img.data[idx+2];
      if (isTealRGB(r,g,b)) tealHits++; else {
        const [h,s,v]=rgbToHsv(r,g,b); if (isTealHSV(h,s,v)) tealHits++;
      }
      if (isGreenRGB(r,g,b)) greenHits++; else {
        const [h2,s2,v2]=rgbToHsv(r,g,b); if (isGreenHSV(h2,s2,v2)) greenHits++;
      }
    }
    return { teal: tealHits>=3, green: greenHits>=3 };
  }
  function updateEnergy(tsNow,i,delta){
    const st=tileState[i]; const v=Math.max(0, delta-config.thrLow);
    const old=st.energyBuf[st.eIdx]; st.energyBuf[st.eIdx]=v; st.eIdx=(st.eIdx+1)%config.energyWindow; st.energySum+=v-old;
    const thr=(config.thrHigh-config.thrLow)*config.energyScale; return st.energySum>=thr;
  }

  // Reveal clustering (fast, aggressive finalization)
  function addToCluster(tsNow, indices){
    if (indices.length===0) return;
    if (!stepCluster) stepCluster = { startTs: tsNow, tally: new Map() };
    for (const idx of indices){
      stepCluster.tally.set(idx, (stepCluster.tally.get(idx)||0)+1);
    }
    lastTealTs = tsNow;
  }
  function finalizeCluster(tsNow){
    if (!stepCluster) return -1;
    let bestIdx=-1, bestCount=-1;
    for (const [idx,count] of stepCluster.tally){
      if (count>bestCount){ bestCount=count; bestIdx=idx; }
    }
    stepCluster=null;
    if (bestIdx>=0){
      const st=tileState[bestIdx];
      const within = st && ((tsNow - st.lastHotTs) < config.dedupeMs);
      if (!within){
        revealSeq.push(bestIdx);
        if (st) st.lastHotTs=tsNow;
        elRevealCount.textContent=String(revealSeq.length);
        return bestIdx;
      }
    }
    return -1;
  }
  function maybeFinalizeCluster(tsNow){
    if (!stepCluster) return -1;
    if ((tsNow - lastTealTs) >= config.revealStepGapMs){
      return finalizeCluster(tsNow);
    }
    return -1;
  }
  function shouldEndReveal(tsNow, tealCountThisFrame){
    // End quickly after last cluster closed and a tiny silence
    const silence = tsNow - lastTealTs;
    return (!stepCluster) && (silence >= config.revealEndSilenceMs) && tealCountThisFrame===0;
  }

  // Per-frame processing
  function processFrame(tsNow){
    if (!hasBoard || !detectionActive) return;
    const img = readBoardImageData(); if (!img) return;

    const tealIndices=[], greenIndices=[];
    const inWarm = (tsNow - warmupStartTs) < config.warmupMs;

    for (let i=0;i<tileRects.length;i++){
      const t=tileRects[i], st=tileState[i];
      const cls=classifyTile(img,t);
      const avg=avgTileLuminance(img,t);
      st.baseline = st.baseline*(1-config.emaAlpha) + avg*config.emaAlpha;
      const delta = st.delta = avg - st.baseline;

      if (inWarm){ st.belowLow = delta<=config.thrLow; st.hold=(delta>=config.thrHigh)?Math.min(config.holdFrames, st.hold+1):0; continue; }

      if (delta<=config.thrLow){ st.belowLow=true; st.lowCount=Math.min(255, st.lowCount+1); st.refractory=0; }
      else { st.belowLow=false; st.lowCount=0; if (st.refractory>0) st.refractory--; }

      st.hold=(delta>=config.thrHigh)?Math.min(config.holdFrames, st.hold+1):0;
      const byHold=(st.hold>=config.holdFrames), byEnergy=updateEnergy(tsNow,i,delta);
      const canRepeatBypass = st.lowCount >= config.belowLowFramesToBypass;
      const canTrigger = (st.refractory===0) || canRepeatBypass;

      if (canTrigger && (byHold||byEnergy)){
        if (phase==='armed' || phase==='reveal'){ if (cls.teal){ tealIndices.push(i); st.refractory=config.refractoryFrames; } }
        else if (phase==='waiting-input'){ if (cls.green){ greenIndices.push(i); st.refractory=config.refractoryFrames; } }
      }
    }

    // FSM
    switch(phase){
      case 'idle': break;

      case 'armed':
        if (!inWarm && config.requireColorToStartReveal && tealIndices.length>0){
          phase='reveal';
          revealSeq=[]; inputSeq=[];
          stepCluster=null; lastTealTs=tsNow;
          addToCluster(tsNow, tealIndices);
        }
        break;

      case 'reveal': {
        // Accumulate current flashes
        if (tealIndices.length>0) addToCluster(tsNow, tealIndices);

        // Close a step if gap reached
        maybeFinalizeCluster(tsNow);

        // If no teal and we already closed last cluster, finish reveal fast
        if (shouldEndReveal(tsNow, tealIndices.length)){
          phase='waiting-input';
          inputSeq=[]; inputStartTs=tsNow;
          revealLenExpected = revealSeq.length;

          // Show first step immediately
          guideHeader.style.display='block';
          guideHeader.textContent = `Step 1 / ${revealLenExpected}`;
        }
        break;
      }

      case 'waiting-input': {
        const expected = revealSeq[inputSeq.length] ?? -1;
        const inputElapsed = tsNow - inputStartTs;

        // Fast acceptance of the expected tile
        if (!inWarm && greenIndices.length>0){
          if (greenIndices.includes(expected)){
            const within = (tsNow - tileState[expected].lastHotTs) < config.dedupeMs;
            if (!within){
              inputSeq.push(expected);
              tileState[expected].lastHotTs = tsNow;
              elInputCount.textContent=String(inputSeq.length);
            }
          } else {
            // Wrong press: flash red but don't block
            badPressTile = greenIndices[0];
            badPressTs = tsNow;
          }
        }

        // Move to next tile instantly (header updates in draw)
        // Completion conditions
        if (inputSeq.length >= revealLenExpected && revealLenExpected>0){
          roundIndex += 1;
          phase='rearming'; rearmTs=tsNow;
          revealSeq=[]; inputSeq=[]; revealLenExpected=0;
          guideHeader.style.display='none';
        }else if (inputElapsed >= config.inputTimeoutMs){
          phase='rearming'; rearmTs=tsNow; revealSeq=[]; inputSeq=[]; revealLenExpected=0; guideHeader.style.display='none';
        }
        break;
      }

      case 'rearming':
        if (tsNow - rearmTs >= config.rearmDelayMs){ phase='armed'; warmupStartTs=tsNow; }
        break;
    }
  }

  // Overlay drawing
  function drawOverlay(){
    updateOverlayBox();

    const vw=overlay.width, vh=overlay.height;
    ctxOv.clearRect(0,0,vw,vh);
    const sx = vw/(video.videoWidth||1), sy = vh/(video.videoHeight||1);

    // Board + tiles
    if (boardRect && video.videoWidth){
      ctxOv.save();
      ctxOv.strokeStyle='rgba(88,176,255,0.95)'; ctxOv.setLineDash([6,4]); ctxOv.lineWidth=2;
      ctxOv.strokeRect(boardRect.x*sx, boardRect.y*sy, boardRect.w*sx, boardRect.h*sy);
      ctxOv.restore();

      ctxOv.save();
      ctxOv.strokeStyle='rgba(140,200,255,0.28)'; ctxOv.lineWidth=1;
      for (const t of tileRects){
        ctxOv.strokeRect(t.x*sx, t.y*sy, t.w*sx, t.h*sy);
      }
      ctxOv.restore();
    }

    // Step-by-step guide (fast advance)
    if (phase==='waiting-input' && revealSeq.length>0 && boardRect){
      const k = inputSeq.length; const N = revealLenExpected || revealSeq.length;
      guideHeader.style.display='block';
      guideHeader.textContent = `Step ${Math.min(k+1,N)} / ${N}`;

      const nextIdx = revealSeq[k] ?? null;
      const now = performance.now();
      const pulse = 0.5 + 0.5*Math.sin(now/150);
      if (nextIdx != null){
        const t = tileRects[nextIdx];
        if (t){
          const x=t.x*sx, y=t.y*sy, w=t.w*sx, h=t.h*sy;
          ctxOv.lineWidth = 3 + 2*pulse;
          ctxOv.strokeStyle = `rgba(34,197,94,${0.55 + 0.35*pulse})`;
          ctxOv.shadowColor = 'rgba(34,197,94,0.5)'; ctxOv.shadowBlur = 12*pulse;
          ctxOv.strokeRect(x,y,w,h);
        }
      }
      // wrong press flash
      if (badPressTile>=0 && (now - badPressTs) < 280){
        const t = tileRects[badPressTile];
        if (t){
          const x=t.x*sx, y=t.y*sy, w=t.w*sx, h=t.h*sy;
          ctxOv.lineWidth = 4;
          ctxOv.strokeStyle = 'rgba(239,68,68,0.9)';
          ctxOv.shadowColor = 'rgba(239,68,68,0.6)'; ctxOv.shadowBlur = 8;
          ctxOv.strokeRect(x,y,w,h);
        }
      }
    } else {
      guideHeader.style.display='none';
    }

    // Editor visuals
    if (editor.mode==='draw' && editor.rect){
      const r=editor.rect, sq=squareFromRectCentered(r,vw,vh);
      ctxOv.save();
      ctxOv.setLineDash([8,6]); ctxOv.lineWidth=2; ctxOv.strokeStyle='rgba(88,176,255,0.95)';
      ctxOv.fillStyle='rgba(88,176,255,0.14)'; ctxOv.fillRect(sq.x,sq.y,sq.w,sq.h); ctxOv.strokeRect(sq.x,sq.y,sq.w,sq.h);
      ctxOv.restore();
    }
    if (editor.mode==='edit' && editor.rect){
      const r=editor.rect;
      ctxOv.save();
      ctxOv.setLineDash([8,6]); ctxOv.lineWidth=2; ctxOv.strokeStyle='rgba(88,176,255,0.95)';
      ctxOv.fillStyle='rgba(88,176,255,0.10)'; ctxOv.fillRect(r.x,r.y,r.w,r.h); ctxOv.strokeRect(r.x,r.y,r.w,r.h);
      ctxOv.restore();
      const hs=editor.handleSize;
      for (const h of getHandleRects(r,hs)){
        ctxOv.fillStyle='rgba(88,176,255,0.95)'; ctxOv.fillRect(h.x,h.y,h.w,h.h);
        ctxOv.strokeStyle='#0b1220'; ctxOv.lineWidth=1.5; ctxOv.strokeRect(h.x,h.y,h.w,h.h);
      }
    }
  }

  function getHandleRects(r,hs){
    return [
      {name:'nw', x:r.x-hs/2, y:r.y-hs/2, w:hs, h:hs},
      {name:'ne', x:r.x+r.w-hs/2, y:r.y-hs/2, w:hs, h:hs},
      {name:'se', x:r.x+r.w-hs/2, y:r.y+r.h-hs/2, w:hs, h:hs},
      {name:'sw', x:r.x-hs/2, y:r.y+r.h-hs/2, w:hs, h:hs},
    ];
  }
  function hitTestHandle(x,y,r,hs){ for (const h of getHandleRects(r,hs)){ if (x>=h.x&&x<=h.x+h.w&&y>=h.y&&y<=h.y+h.h) return h.name; } return null; }
  function pointInRect(x,y,r){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }
  function clampRect(x0,y0,dx,dy,maxW,maxH){
    const x1=clamp(x0+dx,0,maxW), y1=clamp(y0+dy,0,maxH);
    const x=clamp(Math.min(x0,x1),0,maxW), y=clamp(Math.min(y0,y1),0,maxH);
    const w=clamp(Math.abs(x1-x0),0,maxW-x), h=clamp(Math.abs(y1-y0),0,maxH-y);
    return {x,y,w,h};
  }
  function squareFromRectCentered(r,maxW,maxH){
    const cx=r.x+r.w/2, cy=r.y+r.h/2, side=Math.min(Math.max(r.w,r.h), Math.min(maxW,maxH));
    let x=cx-side/2, y=cy-side/2; x=clamp(x,0,maxW-side); y=clamp(y,0,maxH-side);
    return {x,y,w:side,h:side};
  }
  function squareResizeFromCorner(startRect, handle, dx, dy, maxW, maxH){
    const minSide=20; let side=startRect.w, x=startRect.x, y=startRect.y;
    if (handle==='se'){ const desired=side+Math.max(dx,dy); const maxSide=Math.min(maxW-startRect.x, maxH-startRect.y); side=clamp(desired,minSide,maxSide); }
    else if (handle==='ne'){ const desired=side+Math.max(dx,-dy); const maxSide=Math.min(maxW-startRect.x, startRect.y+startRect.h); side=clamp(desired,minSide,maxSide); y=(startRect.y+startRect.h)-side; y=clamp(y,0,maxH-side); }
    else if (handle==='nw'){ const desired=side+Math.max(-dx,-dy); const maxSide=Math.min(startRect.x+startRect.w, startRect.y+startRect.h); side=clamp(desired,minSide,maxSide); x=(startRect.x+startRect.w)-side; y=(startRect.y+startRect.h)-side; x=clamp(x,0,maxW-side); y=clamp(y,0,maxH-side); }
    else if (handle==='sw'){ const desired=side+Math.max(-dx,dy); const maxSide=Math.min(startRect.x+startRect.w, maxH-startRect.y); side=clamp(desired,minSide,maxSide); x=(startRect.x+startRect.w)-side; x=clamp(x,0,maxW-side); }
    return {x,y,w:side,h:side};
  }
  function squareMove(startRect,dx,dy,maxW,maxH){
    const x=clamp(startRect.x+dx,0,maxW-startRect.w), y=clamp(startRect.y+dy,0,maxH-startRect.h);
    return {x,y,w:startRect.w,h:startRect.h};
  }

  // FSM helpers
  function calibrateBaselines(){
    if (!hasBoard) return;
    const data = readBoardImageData(); if (!data) return;
    for (let i=0;i<tileRects.length;i++){
      const t=tileRects[i]; const avg=avgTileLuminance(data,t);
      const st=tileState[i]; st.baseline=avg; st.delta=0; st.energyBuf.fill(0); st.energySum=0; st.eIdx=0;
      st.hold=0; st.refractory=0; st.lowCount=0; st.belowLow=true; st.lastHotTs=0;
    }
    warmupStartTs = performance.now();
  }

  // Loops
  function uiLoop(){ if (!running) return; drawOverlay(); requestAnimationFrame(uiLoop); }
  function videoLoopRaf(){
    if (!running) return;
    const tsNow=performance.now();
    framesInBucket++; if (tsNow-lastFPSTs>=1000){ elFPS.textContent=String(framesInBucket); framesInBucket=0; lastFPSTs=tsNow; }
    if (detectionActive){ processFrame(tsNow); updateStatus(); }
    requestAnimationFrame(videoLoopRaf);
  }
  function videoLoopVFC(now){
    if (!running) return;
    framesInBucket++; if (now-lastFPSTs>=1000){ elFPS.textContent=String(framesInBucket); framesInBucket=0; lastFPSTs=now; }
    if (detectionActive){ processFrame(now); updateStatus(); }
    video.requestVideoFrameCallback(videoLoopVFC);
  }
  function startLoops(){
    lastFPSTs=performance.now(); framesInBucket=0;
    requestAnimationFrame(uiLoop);
    if (typeof video.requestVideoFrameCallback==='function'){ video.requestVideoFrameCallback(videoLoopVFC); }
    else { requestAnimationFrame(videoLoopRaf); }
  }
  window.addEventListener('resize', updateOverlayBox);
  video.addEventListener('loadedmetadata', updateOverlayBox);
  video.addEventListener('play', updateOverlayBox);

  // Editor interactions
  function setOverlayPointer(on){
    overlay.classList.toggle('pe-auto', on);
    overlay.classList.toggle('pe-none', !on);
  }
  overlay.addEventListener('pointerdown', (e)=>{
    if (editor.mode==='idle') return;
    overlay.setPointerCapture(e.pointerId);
    const cr=overlay.getBoundingClientRect();
    const x=e.clientX-cr.left, y=e.clientY-cr.top;
    editor.start={x,y};
    if (editor.mode==='draw'){ editor.rect={x,y,w:0,h:0}; }
    else if (editor.mode==='edit'){
      const h=hitTestHandle(x,y,editor.rect,editor.handleSize);
      if (h){ editor.activeHandle=h; editor.rectStart={...editor.rect}; }
      else if (pointInRect(x,y,editor.rect)){ editor.activeHandle='move'; editor.rectStart={...editor.rect}; }
      else { editor.activeHandle=null; }
    }
    drawOverlay();
  });
  overlay.addEventListener('pointermove', (e)=>{
    if (editor.mode==='idle') return;
    const cr=overlay.getBoundingClientRect();
    const x=e.clientX-cr.left, y=e.clientY-cr.top;
    const dx=x-editor.start.x, dy=y-editor.start.y;
    const maxW=overlay.width, maxH=overlay.height;
    if (editor.mode==='draw' && editor.rect){
      editor.rect = clampRect(editor.start.x,editor.start.y,dx,dy,maxW,maxH);
    }else if (editor.mode==='edit' && editor.rect && editor.activeHandle){
      if (editor.activeHandle==='move') editor.rect = squareMove(editor.rectStart,dx,dy,maxW,maxH);
      else editor.rect = squareResizeFromCorner(editor.rectStart,editor.activeHandle,dx,dy,maxW,maxH);
    }
    drawOverlay();
  });
  overlay.addEventListener('pointerup', ()=>{
    if (editor.mode==='draw' && editor.rect){
      editor.rect = squareFromRectCentered(editor.rect, overlay.width, overlay.height);
      editor.mode='edit'; btnDoneEdit.disabled=false; drawOverlay();
    }else if (editor.mode==='edit'){ editor.activeHandle=null; drawOverlay(); }
  });
  overlay.addEventListener('pointercancel', ()=>{ editor.activeHandle=null; drawOverlay(); });
  window.addEventListener('keydown', (e)=>{
    if (editor.mode!=='edit' || !editor.rect) return;
    const step=e.shiftKey?10:1;
    if (e.key==='ArrowLeft') editor.rect=squareMove(editor.rect,-step,0,overlay.width,overlay.height);
    else if (e.key==='ArrowRight') editor.rect=squareMove(editor.rect,step,0,overlay.width,overlay.height);
    else if (e.key==='ArrowUp') editor.rect=squareMove(editor.rect,0,-step,overlay.width,overlay.height);
    else if (e.key==='ArrowDown') editor.rect=squareMove(editor.rect,0,step,overlay.width,overlay.height);
    else if (e.key==='Escape'){ editor.mode='idle'; setOverlayPointer(false); btnDoneEdit.disabled=true; }
    drawOverlay();
  });

  function commitEditorRectToBoard(){
    if (!editor.rect || !video.videoWidth) return;
    const vw=overlay.width, vh=overlay.height, sx=(video.videoWidth||1)/vw, sy=(video.videoHeight||1)/vh;
    const r=editor.rect;
    boardRect={ x:r.x*sx, y:r.y*sy, w:r.w*sx, h:r.h*sy };
    tileRects = buildTilesFromSquare(boardRect.x,boardRect.y,boardRect.w,boardRect.h);
    hasBoard=true; ensureTileState(); calibrateBaselines();
    btnEditBoard.disabled=false; btnClearBoard.disabled=false;
  }

  // Events
  btnCapture.addEventListener('click', startCapture);
  btnStopCapture.addEventListener('click', ()=>{ stopCapture(); resetDetectionState({clearBoard:true}); drawOverlay(); });

  btnSetBoard.addEventListener('click', ()=>{
    if (!video.videoWidth){ alert('Start capture first.'); return; }
    editor.mode='draw'; editor.rect=null; setOverlayPointer(true); btnDoneEdit.disabled=true;
  });
  btnEditBoard.addEventListener('click', ()=>{
    if (!boardRect){ alert('Set the board first.'); return; }
    const vw=overlay.width, vh=overlay.height, sx=vw/(video.videoWidth||1), sy=vh/(video.videoHeight||1);
    editor.rect={ x:boardRect.x*sx, y:boardRect.y*sy, w:boardRect.w*sx, h:boardRect.h*sy };
    editor.mode='edit'; setOverlayPointer(true); btnDoneEdit.disabled=false; drawOverlay();
  });
  btnDoneEdit.addEventListener('click', ()=>{ if (editor.mode==='edit'){ commitEditorRectToBoard(); editor.mode='idle'; setOverlayPointer(false); btnDoneEdit.disabled=true; drawOverlay(); }});
  btnClearBoard.addEventListener('click', ()=>{ resetDetectionState({clearBoard:true}); drawOverlay(); });

  btnCalibrate.addEventListener('click', ()=>{ if (!hasBoard){ alert('Set the board first.'); return; } calibrateBaselines(); updateStatus(); });

  btnStart.addEventListener('click', ()=>{
    if (!stream){ alert('Start capture first.'); return; }
    if (!hasBoard){ alert('Set the board first.'); return; }
    detectionActive=true; phase='armed'; warmupStartTs=performance.now();
    btnStart.disabled=true; btnStop.disabled=false; updateStatus();
  });
  btnStop.addEventListener('click', ()=>{ detectionActive=false; phase='idle'; btnStart.disabled=false; btnStop.disabled=true; updateStatus(); });

  btnResetRounds.addEventListener('click', ()=>{ resetRounds(); });

  selDifficulty.addEventListener('change', ()=>{ difficulty=selDifficulty.value; updateGridFromDifficulty(); resetDetectionState({clearBoard:true}); drawOverlay(); });

  // Init
  updateGridFromDifficulty();
  buildTimingPanel();
  resetDetectionState({clearBoard:true});

  const ro = new ResizeObserver(()=> updateOverlayBox());
  ro.observe(previewWrap);
})();
</script>
</body>
</html>